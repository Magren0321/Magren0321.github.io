<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Node.js on Magren&#39;s Blog</title>
    <link>https://magren.cn/categories/node.js/</link>
    <description>Recent content in Node.js on Magren&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 24 Jul 2022 00:30:21 +0800</lastBuildDate><atom:link href="https://magren.cn/categories/node.js/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于Yuan-bot🤖</title>
      <link>https://magren.cn/about-yuan-bot/</link>
      <pubDate>Sun, 24 Jul 2022 00:30:21 +0800</pubDate>
      
      <guid>https://magren.cn/about-yuan-bot/</guid>
      <description>oicq是基于Node.js实现QQ(安卓)协议，提供了QQ内常用的功能操作
yuan-bot是基于oicq并使用TS编写以及使用MongoDB作为数据库的QQ机器人。目前项目刚创建，只针对了Q群的精华消息，后续内容会慢慢丰富。
 Github地址：yuan-bot
 这篇文章是该项目的非正经开发日志的历程记录。
背景 我的QQ里面有着一个群，这是我高中以及大学时间玩剑三时候的游戏群。
里面的人个个会玩说话又好听。为了铭记每个小伙伴的一言一语，我们活用了QQ的精华消息功能，将每一句 骚话 经典名言裱在了这个精华消息列表上。
此时精华消息的内容不再是精华， 我们心照不宣地称其为糟粕  
因为自己一时的年少轻狂而给装裱在列表上的小伙伴都叫苦连天（当然也有人以此为乐，是谁我不说，大家懂得都懂），纷纷控诉管理员这里面有着管理员的黑幕！应群友得而诛之！
但道高一尺魔高一丈，卑鄙的群管理不仅无视群友控诉，甚至在前一阵群成立八周年之日推出糟粕周边（有幸本人也拿到了一个），同时为糟粕数量最多的群友颁发了奖杯，大力推行糟粕文化，加上群友民心涣散，群里反对的声音逐渐消失，人人都成乐子人。
至此，糟粕文化达到了群成立以来的一个高潮。   
在糟粕文化逐渐流行的同时，糟粕的数量也不断拔高，群管理发现了一些问题
 糟粕数量最多达到1000，必须删掉部分糟粕消息才可以继续添加，这样会损失一些群历史的糟粕 在这么庞大的数量下，QQ群的精华消息并没有统计或者以时间查看等功能，每次统计都由人工统计，耗费人力 ……  Yuan-Bot 就是为了 糟粕以及乐子 解决上述的问题而生。
启动 git clone https://github.com/Magren0321/yuan-bot.git pnpm install pnpm run serve 过程 作为一个前端，所以技术的选用下意识地就选择了Node.js，找到了 oicq 这个库，它是基于Node.js实现的Android QQ，同时是我感觉功能较为全面的库，具体的使用听我说不如参考其 Api reference
精华数据 oicq其本身封装的群对象里面并没有封装群精华数据（不如说好像还没有开源的库做到了这个，或许是受众太小了使用的频率也不高，所以都没有考虑），所以我得自己动手，丰衣足食。
用Fiddler抓包了PC端的QQ，抓到了精华数据的接口，然后通过 oicq 提供的登录接口获取到Cookie，将其丢进请求头来获取精华消息的数据。
顺便给 oicq 提了个PR（又水了一个PR
然后又又又碰上了一个问题就是，当群里有新增精华消息的时候我并无法通过 oicq 监听到群里的tips，发现这个已经有人在去年8月就提了issues，但是至今没有解决的样子。
原本的计划是打算监听到添加精华消息后，服务器的数据库实时存储新的精华消息，但是现在只能换一种方案，改成了间隔定时器，每隔一定时间对数据进行请求，记录好最新消息的时间戳，以此筛选掉旧的内容。
这个办法虽然我觉得很笨，但是现状我暂时没想到别的办法来实现这个功能。
命令 这个比较容易解决，只需要监听指定群的消息，封装一个类，以字符串作为类中的key，对应的方法作为value，在收到消息后将消息作为key传入，如果class中存在则执行对应的方法就好。  
大概实现就是这样，可以说是平平无奇，毫无亮点🤡
最后（或许也还不是最后？ yuan-bot的功能后续还会继续丰富还有迭代(不过现在上班了，估摸进度会推进的比较缓慢)
🙏感谢 oicq 提供的接口以及文档</description>
    </item>
    
    <item>
      <title>Puppeteer爬取Github指北</title>
      <link>https://magren.cn/puppeteer-get-github/</link>
      <pubDate>Wed, 07 Jul 2021 12:57:21 +0800</pubDate>
      
      <guid>https://magren.cn/puppeteer-get-github/</guid>
      <description>介绍 puppeteer 是一个Chrome官方出品的headless Chrome node库。它提供了一系列的API, 可以在无UI的情况下调用Chrome的功能, 适用于爬虫、自动化处理等各种场景。
使用 安装 npm install puppeteer-chromium-resolver &amp;ndash;save
生成/关闭浏览器 const browser = await (puppeteer.launch({ args: [&amp;#39;--no-sandbox&amp;#39;, &amp;#39;--disable-setuid-sandbox&amp;#39;], //如果是访问https页面 此属性会忽略https错误 ignoreHTTPSErrors: true, headless: true, //改为true则是无头模式，不显示浏览器，在无界面的环境中运行 Chrome })); //关闭 browser.close(); 生成新的tab并且跳转 const page = await browser.newPage(); await page.goto(&amp;#39;https://github.com/&amp;#39;+name+&amp;#39;?tab=repositories&amp;#39;); //跳转到github某个用户的仓库页 在控制台中执行函数（ evaluate() ） //获取当页的所有项目url，同时有下一页仓库的url的话也获取 const rep = await page.evaluate(()=&amp;gt;{ const url = document.querySelectorAll(&amp;#39;.wb-break-all &amp;gt; a&amp;#39;); const next = document.querySelector(&amp;#39;.BtnGroup &amp;gt; a&amp;#39;); let urlList = undefined; let nextUrl = undefined; if(url !</description>
    </item>
    
    <item>
      <title>node.js&#43;express写接口</title>
      <link>https://magren.cn/node-express/</link>
      <pubDate>Mon, 19 Oct 2020 23:17:34 +0000</pubDate>
      
      <guid>https://magren.cn/node-express/</guid>
      <description>前一段时间学习了node.js操作mongoDB数据库，现在追加一篇写接口的记录。
链接数据库 在项目根目录下安装Mongoose
npm install mongoose &amp;ndash;save
利用mongoose来链接MongoDB 在项目中创建db.js文件：
&amp;#39;use strict&amp;#39;; import mongoose from &amp;#39;mongoose&amp;#39;; mongoose.connect(&amp;#39;mongodb://localhost:27017/test&amp;#39;, { useNewUrlParser: true, useUnifiedTopology: true }); const db = mongoose.connection; db.once(&amp;#39;open&amp;#39; ,() =&amp;gt; { console.log( &amp;#39;连接数据库成功&amp;#39; ); }) db.on(&amp;#39;error&amp;#39;, function(error) { console.error( &amp;#39;Error in MongoDb connection: &amp;#39; + error ); mongoose.disconnect(); }); db.on(&amp;#39;close&amp;#39;, function() { console.log( &amp;#39;数据库断开，重新连接数据库&amp;#39; ); }); export default db; 创建数据模型（建一张表） 在test数据库中创建一张名为StudentSchema的表，表中有name和age字段，并且公出。
import mongoose from &amp;#39;mongoose&amp;#39;; //创建schema const StudentSchema = new mongoose.Schema({ name: String, age: Number }) const studentSchema = mongoose.</description>
    </item>
    
    <item>
      <title>node.js &#43; MongoDB</title>
      <link>https://magren.cn/node-mongodb/</link>
      <pubDate>Wed, 16 Sep 2020 23:26:09 +0000</pubDate>
      
      <guid>https://magren.cn/node-mongodb/</guid>
      <description>最近开学事情逐渐多了起来，星空、康课还有学校的课程……一切都开始逐渐步入正轨，唯独我的学习之路还在跑偏。
经常会停下来不知道学什么，也提不起动力学，担心自己学的东西派不上用场，也担心自己半途而废。
也难怪有万事开头难这种说法了。
但是一旦行动起来，忙起来的时候就会感到充实。只要动起来，无论结果怎样，都总比没有尝试过的好。
但行好事，莫问前程
我也纠结过是学习用node.js还是Java去操作后端数据库。 有的人说学node.js，前端工程师都要会这个；也有的人说学java，去学ssm，学spring全家桶；还有的人说node.js没有前途； 最后在网上看到了一个答案， 他说：程序员本身不该受语言的约束，更不该受框架的约束。什么样的场景用什么样的工具。 所谓的没有前途一直都是错误的使用正确的工具。 你得有一颗拿c++造宇宙飞船的心。🚀
node.js是什么？ 根据官方的说法：
Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.
Node.js 就是一個能执行 JavaScript 的环境，而 V8 则是主流浏览器 - Google Chrome 的 JavaScript 引擎，负责、执行 JavaScript。 Node.js再加上一系列的c/c++套件，成功的让我们的服务器端也可以执行JavaScript。
环境安装 node.js安装 下载地址：Node.js官网下载
MongoDB数据库 下载地址：MongoDB官网下载
启动服务 在MongoDB文件夹下的bin目录下用命令行输入：.\mongo 来启动服务
可视化工具 Robo3T 用于可视化操作MongoDB数据库，下载地址：Robo3T
express Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。
express脚手架 express脚手架安装：
npm install -g express-generator
创建express项目：
express test
cd test</description>
    </item>
    
  </channel>
</rss>
