<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Magren&#39;s Blog</title>
    <link>https://magren.cn/post/</link>
    <description>Recent content in Posts on Magren&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 24 Jul 2022 00:30:21 +0800</lastBuildDate><atom:link href="https://magren.cn/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>2021 , 否极泰来</title>
      <link>https://magren.cn/2021-summary/</link>
      <pubDate>Thu, 30 Dec 2021 10:14:21 +0800</pubDate>
      
      <guid>https://magren.cn/2021-summary/</guid>
      <description>2020的总结：2020，遗憾是惊喜的序曲
写在前面 或许是今年的经历比较简单，没有比去年丰富，所以感觉今年过的特别快，然后自己的总结也是不知道从哪里下笔比较好，索性想到什么就写什么吧。
在讲今年的事情之前，先看看去年立的flag完成了几个吧（虽然都忘记的差不多，处于随缘完成状态了
2020立的flag
逛遍广州 学习React 啃掉JavaScript高级程序设计、深入浅出node.js等书籍 做些新东西，为开源做贡献 养成锻炼的习惯 给我早睡！ 培养一门新的特长 在疫情肆虐的情况下逛遍广州已经是不太可能的了，不过依然去了一些地方，比如太古汇几十块钱的甜筒并且大排长龙真是让我印象深刻呢……🥲
这一年里面更多的是提高自己前端方面的能力，加上自己喜欢一边学一边去实现自己脑子里没什么用的idea
所以后面三个flag是达成了，美中不足的是感觉自己做的东西比较简单，没有什么亮点，没有什么拿得出手的东西，希望以后能捡起来做优化或者做重构吧。
然后锻炼……如果因为拿外卖或者吃饭需要来回宿舍六层楼也算锻炼的话，就达成了🤤
早睡……现在是01:37，今年是我上大学以来，或者说我21岁以来，熬夜最频繁，然后时长也是最长的一年，我想我需要花点时间来恢复一个良好的生物钟，至于为什么我下面会说说。
特长：下次一定！（逃
2021 生活、健康 在疫情肆虐，加各种变异新病种的情况下，很幸运没有中奖，前不久在学校打了第三针 因为忙于工作的事，所以夜跑的频率远没有去年那么高，还有养成了熬夜的坏习惯 稍微变胖了些，对于我来说是件好事，去年前年都稳定在100斤，昨天称了后发现……到105了🤧，不想再做瘦子了 在今年自己做饭的机会增多了不少，所以开始研究做饭，在 没钱 有兴致的时候会下厨，但是希望自己厨艺能更好一点🤮 摆盘不行味道也一般的一顿 工作 求职以及工作这两件事占了我的2021的绝大部分，在今年春招的时候就给各路大厂打击得找不着北，跟某个大佬师兄谈心后决心再好好沉淀，去了某个公司做实习生，备战秋招。
在公司适应得很快，多亏了同事以及老大都比较平易近人，也给了我很多鼓励，我想那时候我是一个比较放松的状态，暂时忘掉了求职的压力同时也学到了些东西，但是人往高处走，我还是想趁应届生这个身份再冲冲大厂。
在秋招里因为错过了比较好的时机，加上自己没有调整好状态，感觉一直都在碰壁，有些公司哪怕面完了HR面了都没有一个好的结果，压力一直很大，经常失眠后也落得了熬夜的毛病，有时候干脆直接不睡了然后第二天吃了个早餐才睡，也找过朋友坐在楼梯口 蹭吃蹭喝 彻夜长谈。
为了调整自己的心态，给自己做心理建设的同时又去看了很多的电影、动漫，还有一些书来放松自己，就差直接摆烂，最后在11月上了小米补招的末班车，身为米粉对这个结果也是十分满意😌，求职这件事也就告一段落。
书、影视 前面也提到了，为了调整自己的心态，我让自己去看一些电影、动漫和书来短暂转移自己的注意力，让自己从求职的压力中暂时的解放一下。
书 JavaScript高级程序设计 深入浅出Node.js 代码整洁之道 任天堂全球征服史 岩田先生 影视 有一些以前一直想看，但是却给自己在平时抛在脑后的电影终于补上了。
Pokemon（电影） 哈利波特 魯邦三世 THE FIRST 蜡笔小新（电影） 环太平洋 盗梦空间 蜘蛛侠 英雄无归（实在忍不住跟舍友一块看了枪版，国内上映了会去补票的！） EVA 新世纪福音战士（把网上传颂的神作补了） EVA 真心为你/Air EVA 序 EVA 破 EVA Q EVA 终 Code , Learning 入门前端也有一年多了，这一年重点学了Vue3、React，也用过这两者去实现点东西 熟悉了Webpack和Vite 啃了一些书，加上面试会问基础，所以把前端基础和计网又巩固了下 重新刷LeetCode，这次使用Notion将自己做过的题还有自己的方法做了笔记，虽然现在每日一题有时候还是熟练地点开题解，周赛还是给吊打，但是希望自己能坚持下去，锻炼自己思维，静待量变引起质变 一些有的没的想法 保持谦逊 年少时我觉得我是一个比较自负的状态，现在越长大越自卑，认识的人越多，越发现自己平庸至极，就和“知识越学越少”一样，懂得越多，越发现自己知之甚少。</description>
    </item>
    
    <item>
      <title>关于Yuan-bot🤖</title>
      <link>https://magren.cn/about-yuan-bot/</link>
      <pubDate>Sun, 24 Jul 2022 00:30:21 +0800</pubDate>
      
      <guid>https://magren.cn/about-yuan-bot/</guid>
      <description>oicq是基于Node.js实现QQ(安卓)协议，提供了QQ内常用的功能操作
yuan-bot是基于oicq并使用TS编写以及使用MongoDB作为数据库的QQ机器人。目前项目刚创建，只针对了Q群的精华消息，后续内容会慢慢丰富。
Github地址：yuan-bot
这篇文章是该项目的非正经开发日志的历程记录。
背景 我的QQ里面有着一个群，这是我高中以及大学时间玩剑三时候的游戏群。
里面的人个个会玩说话又好听。为了铭记每个小伙伴的一言一语，我们活用了QQ的精华消息功能，将每一句 骚话 经典名言裱在了这个精华消息列表上。
此时精华消息的内容不再是精华， 我们心照不宣地称其为糟粕 因为自己一时的年少轻狂而给装裱在列表上的小伙伴都叫苦连天（当然也有人以此为乐，是谁我不说，大家懂得都懂），纷纷控诉管理员这里面有着管理员的黑幕！应群友得而诛之！
但道高一尺魔高一丈，卑鄙的群管理不仅无视群友控诉，甚至在前一阵群成立八周年之日推出糟粕周边（有幸本人也拿到了一个），同时为糟粕数量最多的群友颁发了奖杯，大力推行糟粕文化，加上群友民心涣散，群里反对的声音逐渐消失，人人都成乐子人。
至此，糟粕文化达到了群成立以来的一个高潮。 在糟粕文化逐渐流行的同时，糟粕的数量也不断拔高，群管理发现了一些问题
糟粕数量最多达到1000，必须删掉部分糟粕消息才可以继续添加，这样会损失一些群历史的糟粕 在这么庞大的数量下，QQ群的精华消息并没有统计或者以时间查看等功能，每次统计都由人工统计，耗费人力 …… Yuan-Bot 就是为了 糟粕以及乐子 解决上述的问题而生。
启动 git clone https://github.com/Magren0321/yuan-bot.git pnpm install pnpm run serve 过程 作为一个前端，所以技术的选用下意识地就选择了Node.js，找到了 oicq 这个库，它是基于Node.js实现的Android QQ，同时是我感觉功能较为全面的库，具体的使用听我说不如参考其 Api reference
精华数据 oicq其本身封装的群对象里面并没有封装群精华数据（不如说好像还没有开源的库做到了这个，或许是受众太小了使用的频率也不高，所以都没有考虑），所以我得自己动手，丰衣足食。
用Fiddler抓包了PC端的QQ，抓到了精华数据的接口，然后通过 oicq 提供的登录接口获取到Cookie，将其丢进请求头来获取精华消息的数据。
顺便给 oicq 提了个PR（又水了一个PR
然后又又又碰上了一个问题就是，当群里有新增精华消息的时候我并无法通过 oicq 监听到群里的tips，发现这个已经有人在去年8月就提了issues，但是至今没有解决的样子。
原本的计划是打算监听到添加精华消息后，服务器的数据库实时存储新的精华消息，但是现在只能换一种方案，改成了间隔定时器，每隔一定时间对数据进行请求，记录好最新消息的时间戳，以此筛选掉旧的内容。
这个办法虽然我觉得很笨，但是现状我暂时没想到别的办法来实现这个功能。
命令 这个比较容易解决，只需要监听指定群的消息，封装一个类，以字符串作为类中的key，对应的方法作为value，在收到消息后将消息作为key传入，如果class中存在则执行对应的方法就好。 大概实现就是这样，可以说是平平无奇，毫无亮点🤡
最后（或许也还不是最后？ yuan-bot的功能后续还会继续丰富还有迭代(不过现在上班了，估摸进度会推进的比较缓慢)
🙏感谢 oicq 提供的接口以及文档
🛸Power by Magren and made with love
To Be Continued.</description>
    </item>
    
    <item>
      <title>毕业前夕</title>
      <link>https://magren.cn/before-graduation/</link>
      <pubDate>Tue, 03 May 2022 10:14:21 +0800</pubDate>
      
      <guid>https://magren.cn/before-graduation/</guid>
      <description>距离上一篇博文已经过去四个月多了，近期一直在忙着自己的毕设、论文和答辩以及摆烂打游戏😵
兜兜转转忙忙碌碌，历经给打回来五次终于交上去的论文、自己误删了自己后台代码花了一天时间重写（不上传Github的代价），完成了因为一些事故导致尬到整个人无地自容的毕设答辩。最后终于在前一阵子提交了自己的论文最终稿并且通过。
学校到现在也没有通知毕业典礼以及毕业照的安排，想必是因为广州的疫情学校决定取消了（上上届就因为疫情取消了），抱着免掉一些麻烦的庆幸，自己内心又夹杂着一丝可惜😞
但无论怎样现在自己只差一张毕业证就毕业了，大学四年悄然而逝，不禁感慨时光飞快。
受一位朋友（大佬）的影响，自己也想给开源做一些贡献，当然也有提升自己能力的原因，于是在前几天向jike-sdk提出了自己职业生涯中的第一个PR，经历了两三次修改后终于merged，在成就感充满自身的同时也发现自己的代码质量有点低😅，还是得继续努力，为开源做一些贡献。希望有一天自己的能力能被许多人认可，在Github上有许多的followers以及stars（做梦
3月底到的霍春阳大佬写的Vue.js设计与实现，现在依旧在断断续续地看，感觉自己有一点囫囵吞枣了，初看这本书对Vue的设计思路以及实现都讲得挺好的，谁让他才是最懂Vue的那个男人呢？🐶 发现无论什么时候都得好好学英语，阅读国外的技术文档以及跟别人在Github、discord交流的时候，英语底子就显得极为重要，不然就只能在中文频道吹水🤪。以前阅读技术文档的时候都是直接右键翻译，现在尝试着生啃😵，还有根据小伙伴的建议，听听英文歌，看美剧。敲代码或许不用特别好的英语，但是我想英语是突破职业瓶颈的一个契机，更重要的是我想在General频道吹水，能跟全世界各地的人吹水在我看来是一件很cooooooooool的事（跟别人吹水聊天成了第一生产力）。
我语言的边界，就是我 吹水 世界的边界。
我是一个缺乏仪式感的人，毕业于我没有太大的感觉，只是遗憾快乐的时光总是过去的那么快。
大一刚入学过了两三个月，那时候舍友都熟络到了父子关系的地步，我们在宿舍开黑打LOL并叫了一顿烧烤外卖做宵夜，我们还特地下楼去超市买了一大瓶可乐拿上来，一边吃一边吹水聊天，那时候入秋，天气微凉，手中的鸡翅很香。
那是我吃的最香的一顿烧烤，后面总感觉欠缺了什么。希望以后还能常聚，也谢谢他们经常拉着我打游戏，差点把我整成了个老废物 何德何能，在这大学四年里所遇之人皆不偏不倚，亦师亦友。
抱着心中的侥幸还有一些遗憾，静静等待自己拿到毕业证书后毕业那一刻，希望我的小伙伴万事胜意，未来可期。苟富贵！勿</description>
    </item>
    
    <item>
      <title>关于我在2021年求职给卷烂的一些事</title>
      <link>https://magren.cn/2021-job-wanted/</link>
      <pubDate>Wed, 24 Nov 2021 10:14:21 +0800</pubDate>
      
      <guid>https://magren.cn/2021-job-wanted/</guid>
      <description>往年师兄师姐找工作的时候，我看着感觉挺轻松，但是今年到了自己的时候，才发现根本不是那么一回事……
春招 三月开始大部分互联网公司开始开启暑期实习的招聘，自己也一头扎进了跟各路神仙大牛拼卷的校招中。
有着早点跑出学校去实习就业的这种意识多亏了我的一个师兄，在我大二的时候就催着我快点投简历，也告诉我有很多公司有日常实习这种渠道，奈何本人不争气，硬生生的还是拖到了大三下学期😅
暑期实习的时间不长，所以抱着能不出市就不出市的想法，我只挑了广州的互联网公司（后面证明这是个非常错误的决定，因为广州的互联网公司太少了）
初生牛犊不怕虎，没有带着一点练练手的想法，打算一步登天（那挂了岂不是贻笑大方）
我反手把简历直接投给了虎牙，欢聚，bigo，结果是我连面试官都没看着，简历先后挂掉。
尔后简历改改改了又改改改改改，再投给了字节和网易，成功收到了笔试通知
“ACM模式是啥？”
“这个题怎么这么离谱啊”
“怎么跟我在LeetCode上做的题目的难度都不一样”
我想算法这东西，有一类人，他们一道没刷，但是他们依然可以做的出来；有另一类人，练多了他们就能做得出来；我想我是第三类，再怎么练都是不会做
结果依然是连面试官也没见着，尔后一个月收到了感谢信，笑嘻了，原来小丑是我自己🤡
后面不抱希望地把简历投给了腾讯和阿里，意外的有了面试。
在面试腾讯前一晚我基本没怎么睡，或者说睡得很浅，人生第一场面试而且还是腾讯，我弱小的心脏根本顶不住这个压力，也难以抑制住自己的兴奋。
然后我一面结束后五分钟查流程发现挂了😭。后面也才知道，腾讯在广州的是WXG部门，也就是微信事业群，难度可以说是最大的了。
人生总有起起落落的，这不是还有个阿里的面试嘛！
尔后在阿里的面试中，我在没有了解技术背后的原理以及一些基本的概念的情况下，我没有悬念的挂掉了，面试官为了不尴尬后面都在跟我聊家常，真是为难人家了💀
人生总有起起落落，但我的人生怎么就是起起落落落落落落落落落落落落落落落落落呢
再往后我接受了我并非是个普通人，而是一个超级大菜鸡的事实，跟我的师兄商讨后决定先去实习学习东西，等秋招再冲一波大厂✋
刷微博的时候刷到了一个非常有意思的定律，叫吸引定律，指思想集中在某一领域的时候，跟这个领域相关的人、事、物就会被它吸引而来。就是说我给自己定下明确的目标 “秋招进大厂” ，并且相信这一点，那么我秋招就可以进大厂了嘛，我一边心里觉得这挺傻逼，得相信科学，一边在Notion中给自己添加了“秋招要进大厂”这个目标
果然人到了走投无路的时候会相信玄学。
实习 这里要感谢女朋友在我封校期间不能出来看房子的时候帮我看好了要租的房子，不然就太难顶了😓
刚来的时候在公司报道，按着公司的教程装了一些内部用的工具，
结果后面告诉我我的工位不在这边……遂又跑路，跑去了黄埔，发现刚刚装的东西都用不上，怒删😤
来到工位简单认了下一起工作的小伙伴后，接收了项目的地址还有一些文档，还蹭了我们老大的一杯奶茶，欸嘿
好嘞！正式上班！我要写出最优美的代码！解决N多个BUG！良好的代码规范！一眼就看懂的技术文档！
拉下项目：git clone xxxxxxxxxxxxx
安装依赖：npm install
一气呵成！ 好，今天跑来跑去挺累了，明天再努力吧😋 第二天来上班的时候我渐渐有点坐不住了，
周围的小伙伴都在认真写代码的样子，我无所事事，显得我十分格格不入，可恶，我是来学习的啊，要主动点！
“我啥时候才能写bug啊？？”
“你先熟悉项目”
好嘞，今天也辛苦自己了，既然老大都这样说了，明天再努力吧 打破我摸鱼的契机，应该是在某一天，我闲着发慌热心替同事看了个bug。
从那以后就有陆陆续续的bug指派了过来，后面给拉去了新的项目组，跟着老大回到了公司本部，摸鱼的日子更是一去不复返，呜呜呜，黄埔我的黄埔🤧
众所周知，前端对接不止后端，还有UI设计
在蓝湖里看项目的UI的时候，发现有一个404了，我心想这还得了！这个蓝湖是跟新浪旗下的嘛，也会夹图？？？
作为团队的一份子，怒从心头起，恶向胆边生，
但是作为社恐，我选择当作没看到5分钟，说不定UI小哥哥就发现然后解决了呢？
然后五分钟过去了，那个404依然在那里晃我的眼。
按耐不住，我去私聊了ui才知道，那是别人做的缺省图。 两个月的时间总是过去的很快，在八月底的时候我提了离职，甚至还有调休没有用完，可恶啊！
走了流程，把没填完的坑还有锅甩给了另一个同事，跟两个老大还有同事打了招呼后就run了，这两个月比我想象中要充实的多，老大跟同事都挺平易近人，也挺照顾我的（已经不知道喝了多少杯老大请的奶茶了），也学到些东西，至少简历上有一个实际上的落地项目了，不是自己写来学习或者玩的玩具。
好了，打开牛客，看看有什么内推，
4399秋招末班车……啊？都末班车了？？？
秋招 上回书说到，我打开牛客才发现今年九月份，已经是秋招的末班车了……小米顺丰还有一些公司都已经没有笔试批次了😨
开始慌张起来，感觉自己没有准备的特别充分，但也只能硬着头皮投了。
腾讯总是处理最快的那个，投了第二天就约面试了，春招第一个面的是腾讯，现在秋招第一个面的也是腾讯，虽然是深圳的🤔
“你有没有别的有优势的或者擅长的但我没有问到的地方？”
“没有什么特别的了，我感觉我都挺欠缺的”。
这里应该说多一点自己复习到的东西的，但是我脑子抽了，心直口快，直接把面试官逗笑了……也有可能是因为把他逗笑了，他放我进了二面，然而我不争气的在二面挂了😂
接下来的时间是一阵非常漫长的，我颗粒无收的时间。
经常焦虑的睡不着觉，并且觉得自己是秋招废物，忘记有多少在泡池子，也不知道收了多少公司的感谢信，真希望hr们知道我的邮箱除了收感谢信，其实也可以收offer。
眼看着金7银8铜9铁10过去了，已经来到了锡11，心态也越来越放平，(我就是秋招废物！好耶！）在复习还有刷leetcode之余投投补录，没想到给小米捞了起来。
面试官问我： &amp;ldquo;为什么选择小米？”
多年老粉的心按耐不住，于是我很直白地说了我是个米粉。
“那小米成立多少周年了？”
“我不知道😂”</description>
    </item>
    
    <item>
      <title>关于Github Report 👨‍🚀</title>
      <link>https://magren.cn/about-github-report/</link>
      <pubDate>Fri, 30 Jul 2021 14:00:21 +0800</pubDate>
      
      <guid>https://magren.cn/about-github-report/</guid>
      <description>前言🛸 GitHub是通过Git进行版本控制的软件源代码托管服务平台，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、P. J. Hyett和汤姆·普雷斯顿·沃纳使用Ruby on Rails编写而成。截止到2020年1月，GitHub已经有超过4000万注册用户和1.9亿代码库（包括至少2800万开源代码库），事实上已经成为了世界上最大的代码存放网站和开源社区。
Github作为世界上最大的开源社区，对我编程的学习可以说是举足轻重的，曾用它抄别人代码来度过作业的危机， 在之前使用Puppeteer尝试爬取了Github的部分数据，于是脑子一抽， 灵光一闪，决定配合之前写的后台，结合下自己想尝试的react函数式组件去写一个页面来展示一个人Github的一些数据。
项目地址：Github Report
NES.css🚀 NES是20世纪80年代末、90年代初进入中国，是80后最早接触的游戏机，俗称红白机，这是一台使用8位处理器的游戏主机，而NES.css是一款NES风格（8位机）的CSS框架，也是一款像素风的CSS元件库,它没有任何 JavaScript 依赖,只包含CSS。
NES.css提供的组件样式很对我胃口，它还提供了一些很好玩的像素icon。NES.css在默认里只有英文字体是像素风格的，如果是需要别的语言也是像素风格的话，需要自行去下载字体。
👀具体使用参考看官方文档：NES.css
React-spring🌏 在最一开始我就想做一个整页滚动的效果，我每个页面都是100vh，隐藏掉滚动条后监听鼠标滚动（移动端监听touch），滚动执行的方法是整个页面上滑或则下滑100vh（使用margin-top，超出的部分隐藏，并且设置transition来使其有一个动画的效果），同时用时间戳实现了一个节流（单位时间内只执行一次某个方法），以防止用户频繁滚动✍：
function throttle(event, time) { let pre = 0; return function (...args) { if (Date.now() - pre &amp;gt; time) { pre = Date.now(); event.apply(this, args); } } } 效果是有的，但是又感觉有点普通了🤨，接着翻到React-spring文档里看到了Parallax，Parallax可以创建一个可以滚动的容器，然后使用ParallaxLayer包含内容，并且可以设置其偏移量以及速度，就是可以制造视差滚动（页面上很多的元素在相互独立地滚动着），觉得挺好看就立马采用了😆。
在网上有看到过使用background-attachment（背景图像的位置是在视口内固定，还是随着包含它的区块滚动），以及transform（通过设置translateZ，滚动的上下距离也就不一样）来实现，但是看react-spring中的Parallax是使用js实现的，通过监听滚动，实时使用translate设定位置🤔
有时间得要好好看下，文档在这👉：React-spring
React Hook📡 既然是使用了react的函数式组件，那么肯定就绕不开它的钩子函数了。说几个我常用的吧。
useState 为函数式组件引入state，这个函数返回一个数组，数组第一个元素是变量，第二个元素是一个方法，用于改变变量，例如：
// 声明一个叫 “count” 的 state 变量 const [count, setCount] = useState(0); useEffect useEffet这个钩子函数可以说是替换了componentDidMount, componentDidUpdate, componentWillUnmount 这三个生命周期，在组件第一次渲染的时候也会执行useEffect()，具体✍：</description>
    </item>
    
    <item>
      <title>Puppeteer爬取Github指北</title>
      <link>https://magren.cn/puppeteer-get-github/</link>
      <pubDate>Wed, 07 Jul 2021 12:57:21 +0800</pubDate>
      
      <guid>https://magren.cn/puppeteer-get-github/</guid>
      <description>介绍 puppeteer 是一个Chrome官方出品的headless Chrome node库。它提供了一系列的API, 可以在无UI的情况下调用Chrome的功能, 适用于爬虫、自动化处理等各种场景。
使用 安装 npm install puppeteer-chromium-resolver &amp;ndash;save
生成/关闭浏览器 const browser = await (puppeteer.launch({ args: [&amp;#39;--no-sandbox&amp;#39;, &amp;#39;--disable-setuid-sandbox&amp;#39;], //如果是访问https页面 此属性会忽略https错误 ignoreHTTPSErrors: true, headless: true, //改为true则是无头模式，不显示浏览器，在无界面的环境中运行 Chrome })); //关闭 browser.close(); 生成新的tab并且跳转 const page = await browser.newPage(); await page.goto(&amp;#39;https://github.com/&amp;#39;+name+&amp;#39;?tab=repositories&amp;#39;); //跳转到github某个用户的仓库页 在控制台中执行函数（ evaluate() ） //获取当页的所有项目url，同时有下一页仓库的url的话也获取 const rep = await page.evaluate(()=&amp;gt;{ const url = document.querySelectorAll(&amp;#39;.wb-break-all &amp;gt; a&amp;#39;); const next = document.querySelector(&amp;#39;.BtnGroup &amp;gt; a&amp;#39;); let urlList = undefined; let nextUrl = undefined; if(url !</description>
    </item>
    
    <item>
      <title>将博客变成PWA</title>
      <link>https://magren.cn/be-pwa/</link>
      <pubDate>Sat, 03 Apr 2021 22:14:21 +0800</pubDate>
      
      <guid>https://magren.cn/be-pwa/</guid>
      <description>我是少数派的一个读者，成为少数派已经419天。
从少数派里面学到了很多东西，也丰富了自己的眼界，所以少数派APP也是我手机上的常用应用之一，在去年将手机换成了Android后，发现到现在为止Android的APP已经很久没有更新过了，Android客户端一直处于一个“年久失修”的状态，反倒是IOS的一直在更新迭代，更新了UI以及一些新的功能，这让我十分眼红。
但是在少数派3月31号发布的文章中，他们为Android客户端做出了一个解释，并且提出了一个更优解。
继去年少数派网站改版升级后，更符合新版设计的少数派 iOS 客户端 2.0 也在不久前正式上线。可惜由于开发能力实在有限，Android 平台繁杂的机型适配和兼容性问题也着实令人头疼，少数派的 Android 客户端此前一直处于「年久失修」的状态。
好在少数派最终为 Android 客户端找到了一个「更优解」——渐进式网页应用（以下简称 PWA）。在保证内容呈现完整的前提下，PWA 有着比客户端应用更轻量、比网页版功能更强大的全新体验，同时还能兼容 Android、iOS 甚至 Windows 等多个平台。
关于PWA这个概念我是第一次知道，抱着新奇的态度开始Google……
关于PWA PWA 是 Google 于 2016 年提出的概念，于 2017 年正式落地，于 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。
PWA 全称为 Progressive Web App，中文译为渐进式 Web APP，其目的是通过各种 Web 技术实现与原生 App 相近的用户体验。
纵观现有 Web 应用与原生应用的对比差距，如离线缓存、沉浸式体验等等，可以通过已经实现的 Web 技术去弥补这些差距，最终达到与原生应用相近的用户体验效果。
好吧说完上面的官方发言，地道一点说下我自己的体验，就是一个Web页面拿掉了浏览器的壳子，以一个近似app的形式存在手机桌面，与一般的将网页添加到桌面不同，它还有本地通知的能力以及一个缓存的能力，除此以外它可以兼容Android、IOS以及Windows多个平台，对我来说它在打开的时候还有一个页面logo闪屏，很有吸引力。
将自己的博客变成PWA 在体验过少数派的PWA后，我萌生了能否把自己的博客变成PWA的想法，在网上查询了资料后发现入门意外的简单，接下来说说我自己的操作。
添加 manifest.json 这里新建一个manifest.json文件，主要是配置应用图标以及名称等信息，然后这里分享下我的配置，具体的配置介绍可以参考下MDN。
{ &amp;#34;dir&amp;#34;: &amp;#34;ltr&amp;#34;, //指定名称、短名称和描述成员的主文本方向 &amp;#34;lang&amp;#34;: &amp;#34;zh-cn&amp;#34;, //语言 &amp;#34;name&amp;#34;: &amp;#34;Magren&amp;#39;s Blog&amp;#34;, //名字 &amp;#34;short_name&amp;#34;: &amp;#34;Magren&amp;#39;s Blog&amp;#34;, //短名称 &amp;#34;theme_color&amp;#34;: &amp;#34;#ffffff&amp;#34;, //主题颜色 &amp;#34;background_color&amp;#34;: &amp;#34;#d4d4d4&amp;#34;, //启动时闪屏的背景颜色 &amp;#34;display&amp;#34;: &amp;#34;standalone&amp;#34;, //定义开发人员对Web应用程序的首选显示模式。 &amp;#34;start_url&amp;#34;: &amp;#34;.</description>
    </item>
    
    <item>
      <title>写在自己21岁生日</title>
      <link>https://magren.cn/my-21st-birthday/</link>
      <pubDate>Sun, 21 Mar 2021 14:00:21 +0800</pubDate>
      
      <guid>https://magren.cn/my-21st-birthday/</guid>
      <description>21岁 达成成就：与第三旋臂边缘的一颗蓝色星球上的碳基生物一起度过了该行星在所在恒星系内的二十一次公转。
老实说，从20岁开始我对自己生日这件事的态度已经由激动转为了焦虑。
20岁前我盼望着快点长大，憧憬外面的生活，不想拘泥于当下，但是20岁开始，接触了外面的社会，焦虑工作以及自己一事无成，很多事想做好也用力去做好，但是结果还是差强人意。
焦虑归焦虑，该来的会来，该做的还是该做，稍作整理后，我也接受了这种状态。即使没有以前那么热血以及饱含精力，也还是要热爱自己从事的事业，做好自己该做的事，珍惜眼前人。
认清自己 很喜欢罗振宇老师说的一句话: 成长就是你的理想世界碰到了现实世界，掉进去了叫做挫折，爬出来了叫做成长。
在以前我就常常自命不凡，认为自己的人生一定得轰轰烈烈，甚至纠结过清华北大（现在只能仰望），随着年龄增长也开始慢慢认知到了自己的瓶颈和各方面的极限，也渐渐清楚了自己的渺小，但是这种较负面的自我认知导致我失去了部分的信心，不敢轻易地去做尝试，妄自菲薄，对于一些事情也可以说是用自暴自弃的态度去对待，认为自己是绝对做不好的，于是也曾逃避过，以至于我现在时常都在遗憾。
魔兽世界中，如果在达拉然许愿池钓鱼，会钓上很多金币银币铜币，其中一枚叫“安东尼达斯的银币”，上面写着：“请赐予我力量，去接受我所不能改变的；请赐予我勇气，去改变我所能改变的；并赐予我智慧去分辨两者的不同。＂
其实最为关键的是分辨两者的智慧，如果有这一种智慧能以绝对的态度告诉我这件事情我可以做出改变，那么我想我也会打起十二分的信心去做这件事，可是智慧是抽象的，亦没有一个准确的标准，所以我觉得这份智慧得以另一种方式来替代——认知。
很多事情没能如愿其实都是因为没有一个正确的认知，对工作周期的认知，对自身能力的认知，对周边资源的认知……人们也常常因为懒惰而对一件事情早早的定下结论，这样可以省去一个复杂的探讨过程，但是往往会导致一个错误的行为。
清楚的自我认知对我来说是一件困难的事，常常我会因他人的评价，旁人的观点而动摇自己，我自身没有那么强大的心脏，他人泼的冷水，说的一些他认为不上心的话，对我来说却要花较长的时间去消化并且重新振作；我自身也非常容易自满，他人一点好的评价都会使我飘飘然。所以在做一件我没有十足把握的事的时候我都尽量避免让他人知道，没有耳旁风的时候我更能清楚的认识自己。
在21年里我都在逐渐的了解自己，与自己和解，希望这也是一种成长。
做一个有趣的人 我一直想做一个幽默有趣的人，我认为能让别人打从心里发笑是一种非常伟大的力量。
但是我指的幽默并不是指的一个人的接梗能力或者说一些网络热词的能力，就比如说一个人玩游戏玩的很厉害的时候，就说他6；一个人远投三分穿针了也说他6；久而久之6这个数字就会让我审美疲劳，甚至这个热词给滥用在各种事上，导致了这个词或者这个梗的质量下降。
更可怕的是当时间久了我发现6这个数字已经取代了我脑子里原本许多存在的词语，在对待朋友的时候6这个词也成了脑子里第一出现的词，称赞只会666。无疑我缺少了部分独立思考的能力，这也导致了我一些真实的想法没有说出口。
独立思考以及自己独特的见解应该是有趣的前提，希望自己能够以自己的眼睛去观察世界并思考。
心怀感激 虽然21岁伴随着许多遗憾，但是也有许多可爱的人陪伴在身边，这样让我感受到我是被爱着的，光是这样就足够扫除阴霾了。谢谢一直陪伴着我的家人以及朋友。
今年的生日是宝可梦主题！
生活明朗，万物可爱，人间值得，未来可期。</description>
    </item>
    
    <item>
      <title>代码帮我画像素画</title>
      <link>https://magren.cn/pixel/</link>
      <pubDate>Thu, 25 Feb 2021 16:33:21 +0800</pubDate>
      
      <guid>https://magren.cn/pixel/</guid>
      <description>这一阵子迷上了像素风格，很有复古的味道，加上小时候玩宝可梦的时候还是像素风格，牵扯出了太多情怀。
甚至把自己的电脑壁纸也换成了像素风。很有感觉😝 想自己在像素风上创作，但是感觉自己是没有那种艺术细胞……所以就在想，能不能自己把一张正常的图片转换成像素风？🤔
思路⭐ 使用canvas将图片缩小，使其丢失部分像素信息 再将缩小的图片绘制出来 将缩小的图片放大，使能看到其像素点 其实就是小的图片放大，会感觉到糊的效果。
Code💻 禁止浏览器的平滑处理其实就是是否抗锯齿。
用正则表达式限制输入框只能输入0-100，意味着让图片缩放的百分比（100就是没有缩放，达不到像素化的效果）
const pixel = (canvas, image, scale)=&amp;gt; { scale *= 0.01; canvas.width = image.width; canvas.height = image.height; // 将图片缩小 let scaledW = canvas.width * scale; let scaledH = canvas.height * scale; let ctx = canvas.getContext(&amp;#39;2d&amp;#39;); // 禁止浏览器的平滑处理 ctx.imageSmoothingEnabled = false; ctx.mozImageSmoothingEnabled = false; ctx.webkitImageSmoothingEnabled = false; ctx.msImageSmoothingEnabled = false; //将缩小后的图片绘制出来 ctx.drawImage(image, 0, 0, scaledW, scaledH); //将缩小后的图片还原到原来的大小 ctx.drawImage(canvas, 0, 0, scaledW, scaledH, 0, 0, canvas.</description>
    </item>
    
    <item>
      <title>关于ChatRoom</title>
      <link>https://magren.cn/about-chatroom/</link>
      <pubDate>Wed, 10 Feb 2021 18:11:21 +0800</pubDate>
      
      <guid>https://magren.cn/about-chatroom/</guid>
      <description>学习新东西👋 最近这几天在学习React，所以这个项目主要目的是给我熟悉React，我个人是喜欢边学习一样新东西边动手，只有输出才会让我记忆更深刻，其次也会踩到一些光看是不会碰到的坑，加上之前学习node.js好像也没有做什么，于是就想到了结合在一块做一个聊天室。✌
因为是第一次做React，如果觉得有什么需要修改的欢迎提出Issuse，也欢迎你的star⭐
项目地址：ChatRoom
项目截图： 后端 后端基于Node.js + Express + Socket.io + MongoDB
Node.js操作MongoDB以及用express写接口之前都有在博客中大致的总结过：
Node.js+express
Node.Js操作MongoDB
这次用的新东西就是Socket.io。
前人的工作👇 Socket.IO is a library that enables real-time, bidirectional and event-based communication between the browser and the server
即是说Socket.io可以实现服务器与客户端之间的一个实时的双向通信。
在连接Socket.io的之前还得先知道WebSocket，在WebSocket问世之前，在创建拥有双向通信机制的 web 应用程序时，就只能利用 HTTP 轮询的方式，由此产生了 “短轮询” 和 “长轮询”。
短轮询通过客户端定期轮询来询问服务端是否有新的信息产生，缺点也是显而易见，轮询间隔大了则信息不够实时，轮询间隔过小又会消耗过多的流量，增加服务器的负担。
长轮询是对短轮询的优化，需要服务端做相应的修改来支持。但是每次请求还是都要带上HTTP请求头部，而且在长轮询的连接结束之后，服务器端积累的新消息要等到下次客户端连接时才能传递。
Websocket协议就是为了解决长轮询的痛点而诞生的，其基于TCP协议，是一种双全工通信技术、复用HTTP握手通道。它与HTTP协议的唯一关系就是它的握手请求可以作为一个Upgrade request经由HTTP服务器解析，且与HTTP使用一样的端口。
接着是Socket.io，Socket.io底层基于engine.io，封装了WebSocket，其屏蔽了底层细节，让顶层调用非常简单。同时它还支持许多种轮询机制以及其他通信方式，当环境不支持WebSocket的时候它能自动选择最佳的方式来实现网络的实时通信。
使用 引入io设置端口后监听connect事件：
const server = require(&amp;#39;http&amp;#39;).Server(app); const io = require(&amp;#39;socket.io&amp;#39;)(server); server.listen(3001); //端口设置3001 io.on((&amp;#39;connection&amp;#39;, socket=&amp;gt;{ ……………… }) 接着通过最重要的两个api，emit和on来发送以及监听事件
socket.emit(eventName,[ &amp;hellip;args])：发射（触发）一个事件 socket.on(eventName, callback)：监听一个 emit 发射的事件 //监听xxx事件，输出传进来的data对象 socket.</description>
    </item>
    
    <item>
      <title>关于CloudMusic</title>
      <link>https://magren.cn/about-cloudmusic/</link>
      <pubDate>Thu, 28 Jan 2021 16:33:21 +0800</pubDate>
      
      <guid>https://magren.cn/about-cloudmusic/</guid>
      <description>前言 这个项目是我某天在宿舍听歌想到的，从16年注册网易云到现在都有五年的时间了，虽然这个平台现在越来越让我失望，但是听了五年了都听出感情来了，就在这个假期里面花了将近一个月磨磨蹭蹭写出来这个项目。至于为什么写的是移动端页面嘛，是因为那时候我听歌是用着我的手机听的……所以模仿的UI也是安卓版网易云音乐的UI。虽然功能没有全部实现，但是比较核心的播放页面还是做出来了，这篇博客也是记录一下这个项目的至今的实现过程还有一些坑。
项目基于Vue + Typescript + Vuetify UI实现。
项目地址：CloudMusic
已经实现的功能：
登录 获取歌单 创建歌单 删除/取消收藏歌单 播放歌曲 排行榜 每日推荐 推荐歌单 项目截图： 播放 这个可以说是核心功能，毕竟一个听歌的平台不能听歌就说不过去了。
首先歌曲的选择可以来自歌单，可以来自发现页的轮播图，还可以来自播放页面的选择，然后控制歌曲的播放暂停既可以从其他页面下方的播放tab控制，又可以在播放的页面进行控制，如果使用Prop和Emit实在是太多太乱了，所以我这里使用了Vuex。
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。
其实就是把我们需要的组件共享状态抽取出来，以一个全局单例模式管理，然后我们可以在任何一个组件下通过Vuex来修改其状态或者值。
于是我将所选的歌曲ID，以及当前播放的歌单信息，ID传进了Vuex，在播放页面只需要监听Vuex中歌曲id的变化，即可播放新的歌曲；监听Vuex中是否暂停的状态，来控制audio组件暂停或者播放。
播放进度 进度条我用的是Vuetify UI中的slider组件，通过v-model来设定其值。
在audio中通过 @timeupdate 来监听audio当前的播放时间戳，接着与播放总时长相除并乘以100得到当前播放进度的百分比，接着赋值给slider组件即可，进度条左边的时间也是通过当前播放的时间戳转换成的时间。
但是这里会有个问题，就是需要通过移动滑块来修改播放的进度，在刚刚@timeupdate绑定的方法中只是单向的将进度赋值给滑块，并且在音乐播放的时候这个方法是一直在运行的，这样无论我怎样移动滑块，滑块都会立马就瞬移到了当前的播放位置，所以这里还得加一个监听是否正在移动滑块的方法，当移动滑块的时候不将当前播放的进度赋值给滑块，然后当我松手的时候将滑块当前的进度转换成时间戳赋值回给audio的播放时间。
我的解决办法是给滑块组件引入了 @mousedown 和 @mouseup，当鼠标按下的时候将一个变量赋值为true，抬起的时候为false，修改@timeupdate中的方法，设定其只有在该变量为false的时候才会对滑块组件赋值，但是滑动滑块的时候也得修改当前的播放时间，所以给滑块组件引入了 @change ，当手动更改了滑块的值的时候会触发该方法，在这个方法里面对audio的播放进度进行修改。
歌词实现 从后台获取的歌词是一个字符串，但是每行歌词都用了\n标识，所以将字符串以\n分割可以得到每行的歌词，每行歌词里中括号里面的是时间，还得将每句歌词以中括号进行分割，最后将时间转换成时间戳，与歌词放在一块做为一个类放入数组中。
设置一个索引，用于记录是第几行歌词，通过offsetHeight获取到歌词组件的高度来确认歌词中线所在的位置，通过索引乘以每行歌词的高度来判断是否滚动。
其实就是给外部的div设置超出隐藏，然后通过修改mragin-top来实现一个滚动的效果，而margin-top的值是由中线的高度减去索引乘以每行歌词的高度来决定。同时可以通过transition属性来设定其改变的时间。
例如：transition: margin-top 1s;
表示的就是说margin-top属性会在一秒内完成。
关于Vue的自定义指令 在制作的过程中我想实现个功能就是点击某个组件以外的位置的时候隐藏该组件，即点击的不是该组件的时候会执行一个方法。
我查资料的时候发现vue并没有这么一个指令，但是我可以通过自己去自定义这么一个指令来实现这个功能。
首先看看一个自定义的指令对象的钩子函数：
bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下) componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。 接着钩子函数中都有以下几个参数：
el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property： name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=&amp;ldquo;1 + 1&amp;rdquo; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=&amp;ldquo;1 + 1&amp;rdquo; 中，表达式为 &amp;ldquo;1 + 1&amp;rdquo;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 &amp;ldquo;foo&amp;rdquo;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.</description>
    </item>
    
    <item>
      <title>博客迁移至Hugo</title>
      <link>https://magren.cn/move-to-hugo/</link>
      <pubDate>Fri, 08 Jan 2021 14:54:21 +0800</pubDate>
      
      <guid>https://magren.cn/move-to-hugo/</guid>
      <description>先说说为啥要迁移 在这之前用的是hexo + next主题，然后自己心血来潮加了网易云的外链还有live 2d，tag cloud这些东西，也有人说过挺好看的，但是自己看多了就觉得有点花里胡哨，而且当我在网上查阅东西进到别人博客的时候，看到的基本都是hexo + next……有点审美疲劳。
但也很容易理解，hexo比较容易上手而且比较稳定，有着功能齐全并且成熟的主题（说的就是Next），这个时候我的眼光放到了hugo上。
Hugo 依靠Go语言进行开发，并且号称世界上最快的构建网站工具，究竟有多快我也不知道，但是我用hexo生成静态网页的时候还需要等，用hugo就没有等过，给我的感觉就是我敲完命令回车的那一刻他就好了……
另一方面就是hugo支持热加载，在文件修改的内容支持实时地显示在网页上，比起hexo需要点多下刷新来说，还是比较方便的。
hugo虽然有着上述说的优点，但是hugo在知名度上不及hexo，教程还有资料，以及优化配置这些方面在网上相比hexo来说都是比较少的，所以有些东西还得自己慢慢摸索。
搭建 环境 Git
由于hugo依靠go语言，所以还得装Go
接着装hugo
hugo 解压完后只需要将其添加到环境变量中即可。
生成博客 hugo 安装完后可以用命令行运行 hugo new site &amp;lsquo;博客名字&amp;rsquo; ，这样hugo会生成一个用于存放博客的文件夹，里面一般有：
archetypes/ content/ data/ themes/ layouts/ static/ config.toml 一般的配置信息写在 config.toml里面，文章以及一些页面在content里面，archetypes 里面一般放的是使用 hugo new 生成页面的时候头部配置信息格式。themes里面放的是你需要的主题。
主题安装 跟hexo不同，hugo没有自带的主题，所以这个时候运行hugo serve来浏览的时候是一片空白的，所以这个时候我们得去hugo官网主题库里去找喜欢的主题。
同时按照主题给的文档在config.toml里面进行配置，一般下载下来的主题文件夹里有一个exampleSite的文件夹，那是作者的配置示例，如果不知道配置什么的话可以复制作者的示例，然后自行修改即可。
生成博文 使用hugo new posts/xxxx.md 命令，可以使content/posts文件夹中生成你需要的 markdown 文件，用markdown语法编辑即可。
还有要注意的就是新生成的文件上方与hexo不同的是多了一条 draft属性，这是表示是否是草稿，假如是true的话该文件不会渲染成页面，更不会在博客中显示，删掉或者改成false便会渲染了。
添加tag和categories的方法跟hexo是一样的。
生成页面 特别的页面（archives页面等）可以使用 hugo new page/xxx.md生成，例如about页面就 hugo new page/about.md，生成后将draft删掉后添加一条layout属性，表明他是什么页面，about页面的话就layout: about。
浏览以及部署 浏览的话用hugo serve命令，然后地址为 http://localhost:1313/，与hexo略有不同。
执行hugo命令生成静态页面，然后博客的文件夹下会多了一个public文件夹，这个文件夹下就是最后生成的页面，将public文件夹中的文件push到仓库中就好了。
最后 从长远角度看的话，写的博文越多hugo的优势越明显。</description>
    </item>
    
    <item>
      <title>2020，遗憾是惊喜的序曲</title>
      <link>https://magren.cn/2020-summary/</link>
      <pubDate>Thu, 31 Dec 2020 20:17:01 +0000</pubDate>
      
      <guid>https://magren.cn/2020-summary/</guid>
      <description>博客不知不觉就写一年了。 试着对自己过去一年进行一个复盘，就像瑞·达利欧所说的：
生活中的大多数东西都不过是「同类情况的重演」。
得学着从过去中汲取经验。
2020 健康 无论啥时候健康总是首位，1月中旬的时候终于把横在身体里三年的两根钢板拆掉了，熬过来了后想想好像也没什么，虽然当时好像痛的很厉害😅 疫情返校后有在学校里断断续续地跑步，最长的一次不停地跑了八公里🏃 后面也有买瑜伽垫来做俯卧撑+仰卧起坐+深蹲。 可惜以上的项目随着考试月的到来以及天气降温全部停掉了🐷
Code 继续学习着Vue和小程序，稍微看了一点点的node.js，但是都不算精。 前不久买了本JavaScript高级程序设计看，希望能在这个假期里面啃完。 也在试着用自己新学到的东西去敲点小东西出来，除了学到东西外更多的是给我带来了一些成就感。 学习就是要静下心来，好好沉淀（然而还是很菜）。🎯
设备 入了个茶轴的Anne pro2，60%布局+蓝牙真的让我体验到了无线的便利以及轻巧。 当全世界在讨论2077的时候我才购入了动物森友会，跟着她一块岛建中。 买了零件亲自给5s更换电池以及排线，梦回高中。 感情 突然就一年多了。 越来越了解彼此， 这一年里一起去了挺多地方，也在一起努力着 还是希望能好好的一直在一块🌟
日常 日常就是折腾。
疫情在家想给电脑加多根内存条，心血来潮想换换硅脂，结果拧螺丝拧上头导致风扇的一颗螺丝拧花了取不下来。 祸不单行，电脑的电源也坏了……遂又买了电源自己换。
前不久考试那段时间电脑开机以及读取机械硬盘里的数据非常慢，甚至直接卡死……重装系统等各种操作才排查出来是我的机械硬盘坏了，遂拆掉去网上买了个固态，又是突然的心血来潮给自己电脑装了个Ubuntu，但是用不惯，一天后就换回来了。
这台电脑从windows-&amp;gt;macos-&amp;gt;windows-&amp;gt;ubuntu-&amp;gt;windows，真的是玩了个遍。
2021 出行 疫情期间+封校让这一年的出行基本都泡汤了，希望明年能多出去走走，见识见识。 对于不怎么学校的我，先不说出省了，能把广州好玩的地方逛完就不错了。🤔
逛遍广州 能力 学习React 啃掉JavaScript高级程序设计、深入浅出node.js等书籍 做些新东西，为开源做贡献 健康 养成锻炼的习惯 给我早睡！ 生活 培养一门新的特长 最后 2020虽然充满遗憾，但还是要充满对生活的热情。人间值得，未来可期。 遗憾会是惊喜的序曲。</description>
    </item>
    
    <item>
      <title>从输入URL到页面展示</title>
      <link>https://magren.cn/inputUrl/</link>
      <pubDate>Sun, 08 Nov 2020 23:12:57 +0000</pubDate>
      
      <guid>https://magren.cn/inputUrl/</guid>
      <description>最近在准备着前端的面试，这个问题基本是必考题，稍微去网上查阅了一些资料，并且自己整理了下。
总的过程如下：
输入URL DNS解析 建立TCP链接 发送HTTP请求 服务器永久重定向 服务器处理请求并返回一个HTTP响应 浏览器显示HTML 链接结束 输入URL URL的中文名叫统一资源定位符，用于得到资源的位置和访问方法。 其组成为：协议：//主机名:端口号/路径/;参数?查询#信息片段
DNS解析 DNS（域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，得到主机名对应的IP地址的过程就叫做域名解析。 DNS解析的过程其实就是为了寻找哪台机器上有需要的资源，实际上充当了一个翻译的身份，将输入的网址转换成IP地址。 以下是DNS的一个查找顺序：
浏览器缓存：向浏览器缓存中读取访问记录 操作系统缓存：查找在系统运行内存中的缓存 host文件：查找本地硬盘的host文件 路由器缓存：部分路由器会缓存访问过的域名 ISP（互联网服务提供商）DNS缓存：在本地查找不到的情况下，ISP会在当前服务器的缓存中查找 根DNS服务器：根域名收到请求，判断是哪台服务器管理，并返回顶级DNS服务器的IP给请求者。 在查找完以后本地DNS服务器向域名的解析服务器发起请求，本地服务器将IP地址返回给电脑，并将对应关系保存在缓存中。
拓展： DNS的查询方式：
递归：局部DNS服务器负责向其他DNS服务器查询（一般先向该域名的根域服务器查询，接着一级一级向下查询），结果返回给局部DNS服务器后再由其返回个客户端。 迭代：局部DNS服务器把能解析该域名的其他DNS服务器的IP地址给客户端DNS程序，再由该程序向这些DNS服务器查询（用于局部DNS服务器不能回答客户机DNS查询时）。 DNS优化方法：
DNS缓存 DNS负载均衡 为啥需要：当每次请求的资源都在同一台机器上时，机器可能承受不过来而崩掉。 原理：为一个主机名配置多个IP地址，在应答查询饿时候对每个查询以DNS文件中记录的IP地址按顺序返回不同的结果，将访问引导到不同的机器上去。 建立TCP链接 拿到IP地址后就是通过三次握手来建立TCP链接了。
第一次握手：客户端发送SYN（同步序列编号）包到服务器，并且进入SYN_SENT状态，等待服务器确认。 第二次握手：服务器收到SYN包后确认，同时自己也发送一个SYN包，即SYN+ACK包，服务器进入SYN_RECE状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送一个确认包ACK，发送完毕后客户端和服务器进入ESTABLISHED状态。 拓展： 为啥三次握手：为了防止已经失效的链接请求报文突然传送到了服务端因而产生错误。
发送HTTP请求 建立TCP连接后客户端发起HTTP请求，HTTP报文包含三个部分：
请求行：请求方法+URL+协议/版本 请求报头：传递请求的附加信息和客户端自身的信息 请求正文：需要传递的数据 服务器永久重定向 服务器给浏览器响应一个301永久重定向响应，例如访问http://google.com/ 会自动跳转到 http://www.google.com/
目的：
这样就会把访问带www的和不带www的地址归到同一个网站排名下，网站在搜索链接的排名下就不会降低。 用不同的地址会导致缓存的良好性变差，一个页面有多个名字的时候可能会在缓存中出现多次。 服务器处理请求并且返回HTTP报文 后端从固定的端口接收到TCP报文后，会对TCP进行处理，对HTTP协议进行解析，按照报文格式进一步封装成HTTP Request对象，供上层使用。 HTTP响应由4个部分组成：
状态行：协议版本、状态代码、状态描述 响应头：由键值对组成，每行一对，用“:”分割 空行： 分割请求数据 响应正文 拓展： 在大一点的网站中会将请求到反向代理中，将同一应用部署到多台服务器上，将大量用户请求分配给多台机器处理。 即客户端先请求到Nginx，Nginx再请求应用服务器，最后将结果返回客户端。
浏览器显示HTML 浏览器显示HTMl是一个边解析边渲染的过程，大致的过程为：
解析HTML文件构建DOM树 解析CSS文件构建渲染树 浏览器开始布局渲染树并将其绘制到屏幕上 拓展： 关于reflow(回流)和repaint(重绘)：</description>
    </item>
    
    <item>
      <title>node.js&#43;express写接口</title>
      <link>https://magren.cn/node-express/</link>
      <pubDate>Mon, 19 Oct 2020 23:17:34 +0000</pubDate>
      
      <guid>https://magren.cn/node-express/</guid>
      <description>前一段时间学习了node.js操作mongoDB数据库，现在追加一篇写接口的记录。
链接数据库 在项目根目录下安装Mongoose
npm install mongoose &amp;ndash;save
利用mongoose来链接MongoDB 在项目中创建db.js文件：
&amp;#39;use strict&amp;#39;; import mongoose from &amp;#39;mongoose&amp;#39;; mongoose.connect(&amp;#39;mongodb://localhost:27017/test&amp;#39;, { useNewUrlParser: true, useUnifiedTopology: true }); const db = mongoose.connection; db.once(&amp;#39;open&amp;#39; ,() =&amp;gt; { console.log( &amp;#39;连接数据库成功&amp;#39; ); }) db.on(&amp;#39;error&amp;#39;, function(error) { console.error( &amp;#39;Error in MongoDb connection: &amp;#39; + error ); mongoose.disconnect(); }); db.on(&amp;#39;close&amp;#39;, function() { console.log( &amp;#39;数据库断开，重新连接数据库&amp;#39; ); }); export default db; 创建数据模型（建一张表） 在test数据库中创建一张名为StudentSchema的表，表中有name和age字段，并且公出。
import mongoose from &amp;#39;mongoose&amp;#39;; //创建schema const StudentSchema = new mongoose.Schema({ name: String, age: Number }) const studentSchema = mongoose.</description>
    </item>
    
    <item>
      <title>那一片璀璨耀眼的星空</title>
      <link>https://magren.cn/starry-sky/</link>
      <pubDate>Wed, 14 Oct 2020 00:25:54 +0000</pubDate>
      
      <guid>https://magren.cn/starry-sky/</guid>
      <description>大学期间最值得分享的事情我想就是星空了吧，
贯彻了我大学生活的一半，也是我程序员道路上的启蒙。
也留下来过想将星空在前两年带给我的技术还有启发去回馈给星空，希望能延续下去，让下一代有更好的资源。 但是当选择一条路的时候，根本无法预知它的曲折程度。 梳理了一下自己在星空这两年多的历程，也是写了个流水账，是为了能够记录这段非常宝贵的时光，也是希望对后辈以及一些迷茫和踌躇的朋友有一些帮助。
两年前 在校级组织招新摆摊的那天晚上，抱着 看小姐姐 凑热闹的想法走进了人堆， 推掉了学生会的了解邀请，躲掉了学生志愿者， 但是没躲掉星空， 星空也是当时摆摊招新的组织里头唯一一个做互联网技术这一块的，抱着学习的想法，一头扎进了这个充满活力的地方。 经过两次简单的培训还有两次考核后成功的挤进了星空，成为了从两百多个学生里面留下来的三十个人中的一个，当时还是挺自豪的。（仍然记得每次快到考核结果发布的时候就看着手机坐立不安）
进来互相认识不久后就开展了素拓，由于学校的限制我们这一届的素拓就成了在学校里玩游戏， 我的师兄跟我说星空的素拓都被称之为脱单素拓（但我就没见过在素拓里脱单的。） 看我还在犹豫，他跟我说
师兄：其他中心的人也会参加哦，别的中心挺多小姐姐的。
我：我星空服穿好了，什么时候出发？
当时我还觉得都是大学生了，在学校里面跑跑跳跳玩小游戏有什么意思？ 但是最后我们那组是玩的最嗨的一队，甚至拿了奖，是一箱的小零食hhhhhhhhh。
快乐过后接踵而至的就是每周晚自习的任务还有来自谢峰善意的嘲讽。
“你看看你”（指猪）
“你写的代码都是啥”
“你加任务！”
可恶，以后成大佬了一定要怼回去。
一旦埋下改变的种子，机会就会随着你的念头悄然出现
那一段时间真的是在野蛮生长。 从每周一天的晚自习主动申请成了每周两天都去。 做着师兄下发的任务，一边疯狂谷歌百度，然后就认识了Gihub、stackoverflow、CSDN等平台。 大一上学期的时候学校教的也是C，不是Java，所以那时候一边学C一边学Java。 虽然很累，但是很充实，每解决一个BUG每实现一个功能，都知道自己前进了一步。 星训营虽然熬夜敲代码敲得很晚，做成的东西也不算好，但是有一个功能基本实现的产品展示在大家面前的时候还是很有成就感。
夏训营还有冬训营的时候都不是很想留下，虽然就是考完期末考在学校呆一周，每天都去办公室学习。 但估计是考完试了心就飘了，就想要放松下。 可最后我还是被我的副总监强制安排留了下来，他还骗我说他也在，结果每次都没见到过他。 可恶，给算计了。 但是不得不承认这期间学到的东西是挺多的，博客这个领域也是当时的to在分享会上让我有所了解。 主要是大家都在学习，我就不好意思玩。
踏上星空的舞台，抓住每个机会，跟志同道合的朋友一起做热爱的事情，不停地成长自我，真的很酷。
一年前 回到学校的第一件正事就是招新， 说实话跟陌生人打交道这回事应该大部分程序员都不太会，估计是常年跟计算机打交道，成了一个闷骚的性格。 反观传媒那边的人络绎不绝，几乎有新生走过来第一个想了解的都是摄影、视频，让技术小哥们都很眼红。 小知估摸也看不下去了，疯狂的催我们去揽人，估计是怕星空的技术就断在我们手上了吧hhhhh。
面试的时候看着一批批紧张的大一感觉颇有意思，当初我在师兄师姐眼中应该也是这样的吧， 嫩雏内敛，但是充满希望和活力。 但是当大三大四那几个老油条走进来的时候我就傻眼了。有内鬼，终止交易 我寻思着他们的发际线也不像大一的啊，这也能装？
笔试的最后一题是问：你认为程序员都是怎样的一群人？ 加葱在答题的地方画了个画，画了几个在一块小人，然后上面画了几个星星，左上角画太阳右上角画月亮，两个还用双箭头连在了一块，下面有电脑，写了个code。 我们看到那简笔画的时候都想笑，毕竟知道他是来捣乱的，那自然也要顺一下他的意思，就问他是什么意思。
啊，我觉得程序员就是，跟好朋友一起，在同一片星空下，从白天到黑夜都一起努力敲代码学习。
直到现在我也还是觉得，这不仅是对程序员的诠释，也是对星空最好的诠释。我的心中对星空有了个很明确的答案。
因为一些原因，我需要去补上CTO这个职位，但是估计是因为当时的我对星空的发展没有什么好的见解，也并不清楚CTO这个职位是要去承担什么，所以当时校团委的老师是认为我太过稚嫩了吧，不过也不得不承认这的确是我自身能力的问题，事后也好好反思了自己，仅有胆魄但是没有能力是做不成什么事的，格局还有眼界也别局限。
尔后就是培养新进来的六个小星星，他们比我大一的时候要有潜力多了，学的也很快，甚至有一个在进来之前就已经有过开发的经验，后浪后浪，后生可畏。 后辈的成长也是给我带来了压力，我希望能让他们这一年里在这个方向上学到更多的东西，所以我也没停下自己的脚步，也是机缘巧合下看到了晓特的博客，阿里巴巴大佬的博客，应该有点宝可以掏吧？ 事实证明是真有点东西，但是不仅是技术，还有星空。 从他文章里的字里行间我窥探着以前的星空，窥探着隔了几年时间的星空， 坐上抽屉的时光机，跟这个素不相识的人进行了一场交流，从他的嘴里听当年星空的故事。 感觉还是很奇妙，看着一篇故事，而此刻自己就在经历这么一场故事。
当时也有在思索着自己在过去一年学到的东西能否做出什么来反哺给星空，可惜最后都无疾而终，成了个遗憾，反倒是学习前端的路上折腾出来的小玩意上线了，无心插柳柳成荫吧。
成了管理层会变得很累，除了自身技术的学习以外还多了很多的琐事，跟其他方向的同事也有很多意见不合的时候，但是在思想的碰撞时也能学到一点东西，而且看着那几个小兔崽子一边做着我加的任务一边骂我的时候，还是很开心的。
折腾永无止境，在星空的舞台上就要去利用星空的资源，去做出自己想做出的东西，去丰富自己，这不仅是个人的成长，也是相互成就。
现在 为响应学校推行的组织改革，作为校级组织的星空就要结束了。 我应该是第一批知道这个消息的人吧， 9月4日上午进行了校级组织的会议，正式告知了我们这个消息， 9月4日下午，我一个人在办公室逛了几圈，对这个充满故事和活力的地方默默地道别。 往后我们开了管理层的会议，也拉了各中心的小星星开会，最后得出了我们要走的路。 星空学生创新中心准备转型成为一个工作室。</description>
    </item>
    
    <item>
      <title>Vue下的EventBus</title>
      <link>https://magren.cn/vue-eventbus/</link>
      <pubDate>Mon, 12 Oct 2020 11:21:03 +0000</pubDate>
      
      <guid>https://magren.cn/vue-eventbus/</guid>
      <description>EventBus是用于Vue中组件通信的一种方式，常见的父子组件沟通方式有emit和props。
但假如跨组件传参沟通，或者是兄弟姐妹组件之间的传参沟通，使用EventBus或者Vuex就可以避免很多重复的props和emit。
Vuex适合的场景是中大型的项目，管理全站共用的状态。EventBus比较适用于小型的项目，不是太复杂的事件。
使用 EventBus实际上只是一个Vue的实例，接着分别调用这个实例的事件触发和监听来实现通信和参数传递。主要是下面四种方法：
$on：注册监听 $once：监听一次 $off：取消监听 $emit：发送事件 一般页面created的時候就注册监听，当组件销毁时取消监听。
创建一个EventBus 其实就是创建一个Vue的实例
import Vue from &amp;#39;vue&amp;#39;; // 使用 Event Bus const bus = new Vue(); export default bus; 在我们需要发送事件以及接收事件的组件中引入。
import bus from &amp;#39;../common/bus&amp;#39;; 监听 在需要监听的组件中的created中使用bus监听
created() { bus.$on(&amp;#39;getSomething&amp;#39;, target =&amp;gt; { console.log(target); }); } 发送事件 methods: { // 把事件 emit 出去 doSomething(target) { bus.$emit(&amp;#34;getSomething&amp;#34;, target); } } 取消监听 EventBus的监听不会自动关闭，接着会导致的一个情况就是监听会触发多次，所以需要我们用$off取消下绑定。 通常绑定在钩子函数 beforeDestroy() 或者 destroyed() 中
// 移除事件的监听 bus.$off(&amp;#39;getSomething&amp;#39;) // 移除所有事件的监听 bus.$off() </description>
    </item>
    
    <item>
      <title>node.js &#43; MongoDB</title>
      <link>https://magren.cn/node-mongodb/</link>
      <pubDate>Wed, 16 Sep 2020 23:26:09 +0000</pubDate>
      
      <guid>https://magren.cn/node-mongodb/</guid>
      <description>最近开学事情逐渐多了起来，星空、康课还有学校的课程……一切都开始逐渐步入正轨，唯独我的学习之路还在跑偏。
经常会停下来不知道学什么，也提不起动力学，担心自己学的东西派不上用场，也担心自己半途而废。
也难怪有万事开头难这种说法了。
但是一旦行动起来，忙起来的时候就会感到充实。只要动起来，无论结果怎样，都总比没有尝试过的好。
但行好事，莫问前程
我也纠结过是学习用node.js还是Java去操作后端数据库。 有的人说学node.js，前端工程师都要会这个；也有的人说学java，去学ssm，学spring全家桶；还有的人说node.js没有前途； 最后在网上看到了一个答案， 他说：程序员本身不该受语言的约束，更不该受框架的约束。什么样的场景用什么样的工具。 所谓的没有前途一直都是错误的使用正确的工具。 你得有一颗拿c++造宇宙飞船的心。🚀
node.js是什么？ 根据官方的说法：
Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.
Node.js 就是一個能执行 JavaScript 的环境，而 V8 则是主流浏览器 - Google Chrome 的 JavaScript 引擎，负责、执行 JavaScript。 Node.js再加上一系列的c/c++套件，成功的让我们的服务器端也可以执行JavaScript。
环境安装 node.js安装 下载地址：Node.js官网下载
MongoDB数据库 下载地址：MongoDB官网下载
启动服务 在MongoDB文件夹下的bin目录下用命令行输入：.\mongo 来启动服务
可视化工具 Robo3T 用于可视化操作MongoDB数据库，下载地址：Robo3T
express Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。
express脚手架 express脚手架安装：
npm install -g express-generator
创建express项目：
express test
cd test</description>
    </item>
    
    <item>
      <title>Vue下监听页面滚动以及移动端触摸事件</title>
      <link>https://magren.cn/vue-roll/</link>
      <pubDate>Thu, 27 Aug 2020 23:30:42 +0000</pubDate>
      
      <guid>https://magren.cn/vue-roll/</guid>
      <description>无聊刷知乎的时候发现了一个前端设计的宝藏网站awwwards，对上面大佬实现的网站表示望洋兴叹，
但同时自己也跃跃欲试，我也想整一个，万一整出来了呢。
在上面看到了Rally大佬写的GlobeKit,感觉是通过监听滚动事件来进行一个样式的切换，便去了解了一下如何监听页面的滚动事件。
pc端鼠标滚动监听 监听 根据不同的浏览器，在mounted中给页面添加一个滚动监听事件，其中的scrollFun是监听到滚动时候执行的方法
// 浏览器兼容 if ((navigator.userAgent.toLowerCase().indexOf(&amp;#34;firefox&amp;#34;) != -1)) { document.addEventListener(&amp;#34;DOMMouseScroll&amp;#34;, this.scrollFun, false) } else if (document.addEventListener) { document.addEventListener(&amp;#34;mousewheel&amp;#34;, this.scrollFun, false) } } 获取滚动事件的信息 通过传递的event对象获取滚动的属性
//滚动翻页 scrollFun(event: any) { // mousewheel事件中的 “event.wheelDelta” 属性值：返回的如果是正值说明滚轮是向上滚动 // DOMMouseScroll事件中的 “event.detail” 属性值：返回的如果是负值说明滚轮是向上滚动 const delta = event.detail || (-event.wheelDelta); if (delta &amp;gt; 0 ) { // 向下滚动 console.log(&amp;#34;向下滚动&amp;#34;) }else if (delta &amp;lt; 0) { //向上滚动 console.log(&amp;#34;向上滚动&amp;#34;) } } 移动端的touch事件 移动端的上下滚动并不能用上面的方法监听，是因为手机没鼠标吧。 为了实现我想要的效果，我都是直接把滚动条隐藏，然后监听touch事件来自行判断用户是否进行一个上滑下滑的操作。
touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。 touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 touchend事件：当手指从屏幕上离开的时候触发。 事件添加 双引号里是调用的方法</description>
    </item>
    
    <item>
      <title>Vue Typescript下axios的封装和使用</title>
      <link>https://magren.cn/vue-ts-axios/</link>
      <pubDate>Wed, 12 Aug 2020 14:45:50 +0000</pubDate>
      
      <guid>https://magren.cn/vue-ts-axios/</guid>
      <description>8月到了，一个莫名其妙的机遇也砸到了脸上，提着行李一个人跑到了广州跟一个毕业的师兄搞创业的项目，怀着点点的不安以及兴奋，迈出离开学校的第一步。
由于就住在办公室的一间房里，出门即工作，开始了朝五晚九的工作生活，晚上的时候就折腾自己的项目，有点梦回星空时候夏训营的感觉，很累也充实。每天也在掉头发以及烦恼吃什么
自己写的华广地图给自家eo发了一份玩，结果给征收了，上线成了星空的产品，并且要求再进行完善 😟 想了下干脆给每个地点的marker添加一个点击事件，点击后可以看到该地点的详细介绍，不过每个地方都要图片，放在本地太大了，可能会造成卡顿，遂决定放在服务器上，于是重新看了一遍axios同时自己学着网上的一些教程做了一个封装，并解决了跨域的问题。
封装axios import axios, { AxiosRequestConfig, AxiosResponse } from &amp;#39;axios&amp;#39; const showStatus = (status: number) =&amp;gt; { let message = &amp;#39;&amp;#39; switch (status) { case 400: message = &amp;#39;请求错误(400)&amp;#39; break case 401: message = &amp;#39;未授权，请重新登录(401)&amp;#39; break case 403: message = &amp;#39;拒绝访问(403)&amp;#39; break case 404: message = &amp;#39;请求出错(404)&amp;#39; break case 408: message = &amp;#39;请求超时(408)&amp;#39; break case 500: message = &amp;#39;服务器错误(500)&amp;#39; break case 501: message = &amp;#39;服务未实现(501)&amp;#39; break case 502: message = &amp;#39;网络错误(502)&amp;#39; break case 503: message = &amp;#39;服务不可用(503)&amp;#39; break case 504: message = &amp;#39;网络超时(504)&amp;#39; break case 505: message = &amp;#39;HTTP版本不受支持(505)&amp;#39; break default: message = `连接出错(${status})!</description>
    </item>
    
    <item>
      <title>关于HG地图</title>
      <link>https://magren.cn/about-hgmap/</link>
      <pubDate>Thu, 30 Jul 2020 14:53:09 +0000</pubDate>
      
      <guid>https://magren.cn/about-hgmap/</guid>
      <description>最近都在学习前端的路上缓慢前进，在了解了Vue后就开始学习Typescript，每次学习到新东西的时候都会忍不住用新的东西去做一个自己感兴趣的东西，可能自己觉得这样子很Coooooooooooool！👊
之前偶然间也看到了吉珠的地图，觉得很优秀，碰巧我们学校没有相关的产品，只有一张画出来图片地图，稍加思索
考虑到了便携性，决定放在移动端使用 要可以标示出学校的设施地点 校巴的路线以及上下车地点 要有产品的介绍还有学校的介绍 最好能够看到学校实景 加上自己之前学了vue，便打算结合vue来写，说干就干，起飞！✈️
然后第一天就翻车在了创建项目上。
一开始装的Vue的版本是2.x版本，创建新项目的webpack版本是3.6的，使用Typescript的时候会提示需要升级webpack到4.x版本，一开始并没有考虑太多，它提示啥问题就Google啥问题怎么解决（面向搜索引擎编程），大致看了一圈，都是卸载旧版的依赖装新的依赖，同时修改配置，但是他们的教程基本都不一样，唯一一样的地方就是都很复杂，也不知道咋选，就挑了个顺眼的就开始照着写，结果失败了……后面发现Vue3.x版本开始都已经开始适配Typescript了，即创建项目的时候就可以选择是否使用Typescript，同时自动给你配置好……啊这。
旧版本Vue卸载！
npm uninstall vue-cli -g
最新版本Vue安装！
npm install -g @vue/cli
再来一遍，起飞！✈️
项目地址：HgMap 地图链接：华广地图
环境依赖 vue/cli 4.4.6 typescript element-ui：ui组件 vue-class-component：类装饰器 vue-property-decorator：基于 vue 组织里 vue-class-component 所做的拓展 vue2-svg-icon：SVG图标组件 地图资源来自高德地图api 注：由于vue-cli 4版本不自带vue.config.js，故需自行在根目录创建并且配置，否则打包项目会找不到静态资源。
Vue 和 Typescript的使用 前提 script标签加入 : lang=“ts”
&amp;lt;script lang=&amp;#34;ts&amp;#34;&amp;gt; ··· &amp;lt;/script&amp;gt; 创建组件 import { Component, Prop, Vue, Watch } from &amp;#39;vue-property-decorator&amp;#39;; @Component export default class Test extends Vue { } 组件的引入 import Mapmenu from &amp;#39;@/components/Mapmenu.</description>
    </item>
    
    <item>
      <title>在大学里连滚带爬的两年</title>
      <link>https://magren.cn/two-years-of-college/</link>
      <pubDate>Wed, 15 Jul 2020 16:11:42 +0000</pubDate>
      
      <guid>https://magren.cn/two-years-of-college/</guid>
      <description>过完这个暑假自己就是大三的学生了。
曾经大一的时候觉得大三离自己挺遥远，实习工作远在天边，但是现在全都近在眼前。
自己的设备更新了一批，要学习的知识换了又换，星空的换届，师兄师姐的毕业……很多事情都变了，唯一不变的是我依然那么菜，一如既往。
过完这个暑假自己就是大三的学生了。 曾经大一的时候觉得大三离自己挺遥远，实习工作远在天边，但是现在全都近在眼前。 自己的设备更新了一批，要学习的知识换了又换，星空的换届，师兄师姐的毕业……很多事情都变了，唯一不变的是我依然那么菜，一如既往。
大一 自己说出来可能都不信。 大一的压力比我大二的时候还大，可能是因为那时候都在想着怎么生存吧。 怎么在星空生存。
刚开学组织招新的时候避开团委，避开校会，然后给星空一个挺有气质的师姐骗了进来。 虽然进来后我就一直没有再见到过这个师姐。 但是既来之则安之，就当学习点东西。 原本是这么打算的，直到经历了两次考核，才意识到好像不努力是会给淘汰掉。
似懂非懂的看完了师兄发来的资料， 写着乱七八糟不带注释的代码， 莫名其妙的完成了要我们实现的功能， 熬夜逃课来完成x训营中小组的idea。 也是初生牛犊不怕虎，经常缠着师兄师姐问七问八，虽然也经常遇到他们不回我然后我自己一个人折腾出来的情况，也曾经把师兄师姐问的烦躁过。。。 依稀记得是给臭骂了一顿。
大一是最投入的时候，没有什么好迷茫的，学就完事了。 也没什么特别的理由，就是不想输。
大二 以为自己一jio直接成CTO了，没想到还是给打回原形，做回了一个副总监。 这个职位如果真给我做也是我捡漏来的，现在这样反而松了一口气。 给pass了还是很不爽，但是也的确是自己欠缺很多。
招新的时候也知道了星空一个传统， 老一辈的会在招新的时候回来装萌新来玩玩。 在我跟一个人游说半个小时他告诉我是自己人的时候，我决定把这个传统发扬下去。（还我名片！）
面试也是一个机会，老一辈的真的不放过，全是内鬼。 我的CTO不由分说进来拿了张我们的问卷就开始作答了， 最后一题是你认为程序员都是怎样的一群人（具体题目我忘了，但是大致的意思是这样吧），新生都是正儿八经的回答，
“钻研在技术领域” “认真学习” “很严谨”
但是只有他的是画了个画，画了几个在一块小人，然后上面画了几个星星，左上角画太阳右上角画月亮，两个还用双箭头连在了一块，下面有电脑，写了个coding。 我们看到那简笔画的时候都想笑，毕竟知道他是来捣乱的，那自然也要顺一下他的意思，就刁难他：“你在我们的题目下画了一幅画，我们可以认为你对这次面试的心态是不端正的对吗，或者你给我们解释下你这副画是什么意思。”
啊，就是我觉得程序员就是，跟好朋友一起，在同一片星空下，从白天到黑夜都一起努力敲代码学习。
这也成了我心中最憧憬的答案。 看着他日渐攀升的发际线我多了一丝敬意。他临走去北京新浪实习的时候碰巧我在买奶茶，送了他上车后他说下次回来请我吃饭，虽然我现在都还没等到。
一个副总监的开始无非就是重复上一届副总监的开始， 给新生讲讲课，内容所差无几，甚至连考核都是一摸一样的。 也曾一腔热血想做点产品出来，但是想法都给驳回， 老师想着做单一功能，产品简洁的项目，就差没直接告诉我“小程序”这三个字了。 打不过就加入！ 遂开始学习前端并决定往前端的方向走。
疫情直接让我一个学期呆在了家里， 抛弃了在学校的社交，不用担心是否能抢到饭，换来的是我在家更安逸的玩电脑和玩手机。 整一个就是20岁的少年胡适。 不过也是有好处的， 在开会还有给大一的教东西的时候，我看不到下面的人了，省去我把他们想象成大头菜的想象力。
在每次开会的时候胖师姐总会出现，然后也总会站出来发言，给我们一些建议还有灌几壶鸡汤， 甚至已经自封成为我们技术研发中心的程序员鼓励师。 虽然我觉得听她的鼓励不如自强，但是有这么一个职位总聊胜于无。 我想星空对她来说是一个十分重要的存在吧。 借了她的算法导论到现在还放在办公室里头，也不知道还有没有机会给回她了。
最后 待开学了就差不多要换届了吧，大一新生的活力让我这个大二的感觉自己是真的老了。 初中的时候以为考个好的高中就安稳了， 高中的时候以为上了大学就安稳了， 上了大学发现还有很多事情要去担忧， 总是不能停下脚步，也不知道下一步该踏哪个方向， 大二的最后，带着遗憾还有不舍继续前往下一站。</description>
    </item>
    
    <item>
      <title>用vue实现的期末作业</title>
      <link>https://magren.cn/vue-homework/</link>
      <pubDate>Fri, 10 Jul 2020 13:28:29 +0000</pubDate>
      
      <guid>https://magren.cn/vue-homework/</guid>
      <description>终于度过了紧张刺激的期末以及三个大作业两个大作业的答辩。
最没有把握的科目居然是这个学期唯一的开卷考——hadoop，考的东西我翻书也翻不到，虽然操作系统也挺难的，但好歹别人是46开（平时分占比6，期末考试占比4）。
其实主要的还是自己没怎么听，嘿嘿。
零 这个学期我们有一门课是软件工程，幸运的是这门课没有期末考，不幸的是这个老师要我们写6000字的论文（6000字啊！）。 论文是从几个题目里面挑一个来写，基于好写容易理解同时谷歌/百度后有很多样板以方便我们copy的原则，我们小组选了学生学籍管理系统。 老师：“这次作业不查重，你们也不用把这个项目实现，只要模仿我给你们的样板把他写出来就好了” 前面6000字给我带来的冲击小了一半，虽然我文笔挺差，但是我复制粘贴起来真的不含糊。
就这样我殚精竭虑地想着方法来混过这一次作业。 但是人有时候偷着懒，却又对别人的努力感到惶恐不安。 快到截止的时间我准备动手的时候，舍友突然在我们的舍友群里信息轰炸。 “xx真的把他们选的项目做出来了喂！” “什么东西？” “就是软件工程那个” 我也可以赞叹一句，然后就接着躺在床上刷手机，安稳混过这个期末。退一步海阔天空，但是忍一时越想越气。
Somebody has to win, so why not be me?
我也得动手搞一个，前一阵子看了下vue，就当作拿来练练手了，这样就算失败也是有理由的了吧（自我安慰
一、面向搜索引擎编程 说实话，因为这是第一次是实际上手，所以我早就想到肯定会踩到很多坑，但是我没想到一上来就给了我一个下马威。
页面最上方存在白条问题 我开始写好了一个登陆注册的页面，但是无论我怎么更改css属性，最上方都存在一个白条，特地去谷歌搜索也是搜索出来一堆css的属性设置（虽然的确是样式的问题）。 最后钻牛角尖的我不停的翻找答案，最后在一个与这个问题毫不相干的文章上找出了解决的办法，同时真的给我科普了一波。
首先index.html是项目的运行入口，在body体中只有一个div标签，其id为app，这个id将会连接到src/main.js内容， 然后main.js中又初始化vue的实例，也就是说通过main.js我们关联到App.vue组件。 接着在App.vue组件中，标签将会把路由相关内容渲染在这个div里，而路由的内容，则在index.js里。 在index.js里面，将我们写好的组件发布成路由。
以上就是vue项目的运行加载过程，接着在网页上F12查看我的页面属性，发现是一个body设置了外边距8px，但是我写的登陆页面（组件）已经设置了背景铺满，而我们的组件是渲染到App.vue里的div，那么是不是我给div添加一个外边距为0的样式就可以解决？ 于是我在App.vue里面的div添加样式，让它的外边距为0，成功显示了我想要的结果。
&amp;lt;template&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34; style=&amp;#34;margin: 0px;&amp;#34;&amp;gt; &amp;lt;router-view/&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/template&amp;gt; 因为最终所有的路由都会给加载到index.html里面，所以在html里的body添加一个外边距为0的样式也可以解决这个问题。
登陆界面 传参问题 首先说说我了解到的页面之间跳转传参的方式，一个是query，另一个是params
query传参以及接收 传参
this.$router.push({ path: &amp;#39;/Home&amp;#39;, query: { id: res.objectId, } }) 接收
this.$route.query.id params传参以及接收 传参
this.$router.push({ name: &amp;#39;Home&amp;#39;, params: { id: res.objectId, } }) 接收</description>
    </item>
    
    <item>
      <title>es6中的promise</title>
      <link>https://magren.cn/web-promise/</link>
      <pubDate>Wed, 27 May 2020 21:29:47 +0000</pubDate>
      
      <guid>https://magren.cn/web-promise/</guid>
      <description>Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。
有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。
Promise也有一些缺点：
首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 promise的特点 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise的对象状态改变，要么是成功，要么就是失败，只要发生这两种情况，状态就会凝固，称为resolvd（已定型）。改变发生后，再添加回调函数，也是会得到这个结果。 用法 创造Promise实例 Promise对象是一个构造函数，用来生成Promise实例。
const promise = new Promise(function(resolve, reject) { if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。
then方法 接着用then方法指定resolved状态和rejected状态的回调函数：
promise.then(function(value) { // success }, function(error) { // failure }); 第一个函数是状态对象变为rejected的调用，第二个是resolved的调用，第二个函数是可选的。
then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。
promise.then(function(value) { }.then(function (comments) { console.log(&amp;#34;resolved: &amp;#34;, comments); }, function (err){ console.log(&amp;#34;rejected: &amp;#34;, err); }); catch方法 用于指定发生错误时的回调函数。</description>
    </item>
    
    <item>
      <title>HTML的DOM和浏览器的BOM</title>
      <link>https://magren.cn/web-dom-and-bom/</link>
      <pubDate>Sat, 09 May 2020 17:52:32 +0000</pubDate>
      
      <guid>https://magren.cn/web-dom-and-bom/</guid>
      <description>记录下自己最近看的知识点。
HTML DOM (文档对象模型) 概述： 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。
查找HTML元素 通常，通过 JavaScript可以操作需要操作 HTML 元素。
为了做到这件事情，必须首先找到该元素。有三种方法来做这件事：
通过 id 找到 HTML 元素：var x=document.getElementById(“intro”); 通过标签名找到 HTML 元素：var y=document.getElementsByTagName(“p”); 通过类名找到 HTML 元素：var x=document.getElementsByClassName(“intro”); 改变HTML内容 使用 innerHTML 属性。
&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p id=&amp;#34;p1&amp;#34;&amp;gt;Hello World!&amp;lt;/p&amp;gt; &amp;lt;script&amp;gt; document.getElementById(&amp;#34;p1&amp;#34;).innerHTML=&amp;#34;新文本!&amp;#34;; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 改变HTML样式 使用style
&amp;lt;body&amp;gt; &amp;lt;p id=&amp;#34;p1&amp;#34;&amp;gt;Hello World!&amp;lt;/p&amp;gt; &amp;lt;p id=&amp;#34;p2&amp;#34;&amp;gt;Hello World!&amp;lt;/p&amp;gt; &amp;lt;script&amp;gt; document.getElementById(&amp;#34;p2&amp;#34;).style.color=&amp;#34;blue&amp;#34;; document.getElementById(&amp;#34;p2&amp;#34;).style.fontFamily=&amp;#34;Arial&amp;#34;; document.getElementById(&amp;#34;p2&amp;#34;).style.fontSize=&amp;#34;larger&amp;#34;; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; 使用事件 &amp;lt;body&amp;gt; &amp;lt;h1 id=&amp;#34;id1&amp;#34;&amp;gt;我的标题 1&amp;lt;/h1&amp;gt; &amp;lt;button type=&amp;#34;button&amp;#34; onclick=&amp;#34;document.getElementById(&amp;#39;id1&amp;#39;).style.color=&amp;#39;red&amp;#39;&amp;#34;&amp;gt; 按钮&amp;lt;/button&amp;gt; &amp;lt;/body&amp;gt; JS中定义函数绑定事件 var funcc = function () { alert(&amp;#34;hello world&amp;#34;) } var aa = document.</description>
    </item>
    
    <item>
      <title>前端基础里一些杂七杂八的知识点</title>
      <link>https://magren.cn/web-knowledge/</link>
      <pubDate>Sat, 02 May 2020 16:34:16 +0000</pubDate>
      
      <guid>https://magren.cn/web-knowledge/</guid>
      <description>其实在大一就有学习前端的想法，也就多多少少了解了一点html和css，但是那时候身在安卓方向，就还是以安卓为主，也没有坚持下去。
工程师嘛，无论是什么工程师，局限于一个领域上所学到的东西肯定是有限的，it界那么大，总得看看别的地方。
如果硬要说我想成为什么工程师，我希望我能成为一个全栈工程师吧（有能力的话
杂七杂八的要点 这里主要是记了一些我需要重要理解或者容易忘记的知识点。没有一个固定的逻辑顺序。
定位問題 最常用的两个：absolute 和 relative
absolut: 脱离原来的位置定位。对最近有定位的父级进行定位，假如没有则相对文档进行定位。 relative: 保留原来的位置进行定位。相对自己原来的位置定位。 z-index: 改变元素的层面，代表该元素的Z轴，默认是0。
当元素使用float属性定义元素往哪个方向浮动的时候，需要后面的元素不再继续浮动在后面的时候，可用：
.nav::after{ content:&amp;#34;&amp;#34;; display:block; clear:both; } 字体 当字体超出长度，为了页面整洁美观，多余的字体用……表示： .product-buyer-name { overflow: hidden; /*隐藏超出单元格的部分。*/ text-overflow: ellipsis; /*文字超出部分用省略号*/ white-space: nowrap; /*保证无论单元格（TD）中文本内容有多少，都不会自动换行，此时多余的内容会在水平方向撑破单元格*/ } 网页上的一些小图标 我一直以为，在网页上的一些小图标是通过插入img来显示的，但是再深入一点了解到，类似淘宝网上的tab栏的小图标是通过一个自定义显示出来的。 这里我规划到了字体类是因为当我们需要显示部分字体，但是电脑上没有该字体的时候是无法显示的，这里我们就要用一样的方法，将这个字体的资源加载进去，达到一个显示他人电脑字体不存在也依然可以看到该字体的效果。
淘宝网tab栏 那么这种字体资源还有图标资源该怎么来呢，当然是， Google或者百度啦 在阿里巴巴矢量图标库上有挺多资源，我们在里面挑选我们需要的资源并且加入购物车后下载源码
阿里巴巴矢量图标库 加入购物车 下载到的源码里有资源的文件以及他一个css的demo，在使用上我们先拷贝资源文件后。
拷贝项目下面生成的font-face @font-face {font-family: &amp;#39;iconfont&amp;#39;; src: url(&amp;#39;iconfont.eot&amp;#39;); src: url(&amp;#39;iconfont.eot?#iefix&amp;#39;) format(&amp;#39;embedded-opentype&amp;#39;), url(&amp;#39;iconfont.woff&amp;#39;) format(&amp;#39;woff&amp;#39;), url(&amp;#39;iconfont.ttf&amp;#39;) format(&amp;#39;truetype&amp;#39;), url(&amp;#39;iconfont.svg#iconfont&amp;#39;) format(&amp;#39;svg&amp;#39;); } 定义使用的iconfont使用样式 .iconfont{ font-family:&amp;#34;iconfont&amp;#34; !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;} 挑选相应图标并获取字体编码，应用于页面 &amp;lt;i class=&amp;#34;iconfont&amp;#34;&amp;gt;&amp;amp;#x33;&amp;lt;/i&amp;gt; JavaScript 中 var,let,const的区别 const:声明一个只读的常量，一旦声明，常量的值就不能改变。 let:声明的变量只在 let 命令所在的代码块内有效。</description>
    </item>
    
    <item>
      <title>Android的EventBus使用</title>
      <link>https://magren.cn/android-eventbuts/</link>
      <pubDate>Thu, 16 Apr 2020 15:43:52 +0000</pubDate>
      
      <guid>https://magren.cn/android-eventbuts/</guid>
      <description>这两天在网上想着找Android系统学习的路线，然后发现了阿里云上的阿里巴巴Android开发手册，虽然网上已经有免费下载的地方了，不过凭着不能白嫖的感觉，我还是花钱支持了下，其实就卖一块钱，而且还有一份考试证书的资格，总的来说还是很舒服的。
这两天在网上想着找Android系统学习的路线，然后发现了阿里云上的阿里巴巴Android开发手册，虽然网上已经有免费下载的地方了，不过凭着不能白嫖的感觉，我还是花钱支持了下，其实就卖一块钱，而且还有一份考试证书的资格，总的来说还是很舒服的。
网址在下面：
阿里巴巴Android开发手册
估摸是我接触的太少的缘故，在一开始的第一条我就懵掉了
【强制】Activity 间的数据通信，对于数据量比较大的，避免使用 Intent + Parcelable 的方式，可以考虑 EventBus 等替代方案，以免造成 TransactionTooLargeException。 这个EventBus……是啥？？？
EventBus概述 EventBus是一个Android事件发布/订阅框架，通过解耦发布者和订阅者简化Android事件传递，这里的事件可以理解为消息。事件传递既可以用于Android四大组件间通讯，也可以用于异步线程和主线程间通讯等。 传统的事件传递方式包括：Handler、BroadcastReceiver、Interface回调，相比之下EventBus的有点是代码简洁，使用简单，并将事件发布和 订阅充分解耦。
在这里面，又有三个对象：
事件Event：就是消息，分为一般事件和Sticky（黏性）事件，Sticky事件的特殊在于，当事件发布后，再有订阅者订阅该类型事件，依然能收到该类型 事件的最近的一个Sticky事件 订阅者Subscriber：订阅事件的对象，当发布者发布事件猴，EventBus会执行订阅者的事件响应函数。订阅者通过register接口订阅某个事件类型，unregister接口退订 发布者：发布事件的对象，通过post接口发布事件，黏性事件通过postSticky Github地址：EventBus
使用 道理我都懂，但是我得知道它是怎么用的，不然日后复制起来粘贴在哪都不知道，于是我在网上找到了它的使用方法。
一般事件 自定义一个事件类 public class Event { String message; public Event(String message){ this.message = message; } public String getMessage() { return message; } } 在需要接收消息的页面注册 EventBus.getDefault().register(this); 接收消息的方法 @Subscribe(threadMode = ThreadMode.MAIN) public void getEvent(Event event) { msg = event.getMessage(); tv.setText(msg); } 发送事件 @OnClick(R.id.bt_return) public void renturnActivity(){ //发送事件 EventBus.</description>
    </item>
    
    <item>
      <title>Android自定义view的定义</title>
      <link>https://magren.cn/android-custom-view/</link>
      <pubDate>Tue, 14 Apr 2020 15:16:34 +0000</pubDate>
      
      <guid>https://magren.cn/android-custom-view/</guid>
      <description>自定义 View 就是通过继承 View 或者 View 的子类，并在新的类里面实现相应的处理逻辑（重写相应的方法），以达到自己想要的效果。
分类 自定义ViewGroup：自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或各种Layout，包含有子View。 自定义view: 在没有现成的View，需要自己实现的时候，就使用自定义View，一般继承自View，SurfaceView或其他的View，不包含子View。 构造函数 无论是我们继承系统View还是直接继承View，都需要对构造函数进行重写，构造函数有多个，至少要重写其中一个才行。
public class TestView extends View { /** * 在java代码里new的时候会用到 * @param context */ public TestView(Context context) { super(context); } /** * 在xml布局文件中使用时自动调用 * @param context */ public TestView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } /** * 不会自动调用，如果有默认style时，在第二个构造函数中调用 * @param context * @param attrs * @param defStyleAttr */ public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } /** * 只有在API版本&amp;gt;21时才会用到 * 不会自动调用，如果有默认style时，在第二个构造函数中调用 * @param context * @param attrs * @param defStyleAttr * @param defStyleRes */ @RequiresApi(api = Build.</description>
    </item>
    
    <item>
      <title>Rxjava的CompositeDisposable</title>
      <link>https://magren.cn/rxjava-composite-disposable/</link>
      <pubDate>Sun, 29 Mar 2020 15:13:03 +0000</pubDate>
      
      <guid>https://magren.cn/rxjava-composite-disposable/</guid>
      <description>之前在学习Rxjava的时候发现仍有部分知识点自己遗漏了，不够严谨，在这里补充多一个知识点。那就是CompositeDisposable类。
在用Rxjava配合Retorfit的时候，发送请求，拿到数据后我们要让数据显示在视图中的时候往往会刷新页面，但假如，我们发送请求出去的时候网络比较差，返回数据比较慢，然后我们又手快的关闭了当前这个Activity，那RxJava当拿到返回的数据的时候去刷新界面就会报空指针异常了。就是说，请求过程中，我们的UI层Destroy的时候，不及时取消订阅，就会造成内存泄漏。这里就要用到我们的CompositeDisposable。
使用 使用的方法大致就是三步：
ui层创建的时候，实例化我们的CompositeDisposable类。 把订阅返回的disposable对象加入到我们的管理器中。 ui层销毁的时候清空订阅对象。 创建ui的时候实例化 @Override public void onStart() { if (mSubscriptions == null) { mSubscriptions = new CompositeDisposable(); } } 添加disposable对象 netWork.getInstance().getDataService() .translateYouDao(q,from,to,appID,salt,sign,signType,curtime) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer&amp;lt;TranslationBean&amp;gt;() { @Override public void onSubscribe(Disposable d) { mSubscriptions.add(d); //这里添加到容器中 } @Override public void onNext(TranslationBean translationBean) { List&amp;lt;TranslationBean&amp;gt; list_word = new ArrayList&amp;lt;&amp;gt;(); list_word.add(translationBean); mView.showResult(list_word); } @Override public void onError(Throwable e) { mView.showConnection(); } @Override public void onComplete() { } }); ui层销毁时候解除订阅 @Override public void onDestroy() { if (mSubscriptions !</description>
    </item>
    
    <item>
      <title>Android的rxjava2</title>
      <link>https://magren.cn/android-rxjava/</link>
      <pubDate>Fri, 13 Mar 2020 14:59:35 +0000</pubDate>
      
      <guid>https://magren.cn/android-rxjava/</guid>
      <description>RxJava是利用观察者模式来实现一些列的操作，所以对于观察者模式中的观察者，被观察者，以及订阅、事件需要有一个了解。
Observable：在观察者模式中称为“被观察者”； Observer：观察者模式中的“观察者”，可接收Observable发送的数据； subscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅； Subscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.
观察者模式 rxjava的实现主要是通过观察者模式实现的。
A 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感,需要在 B 变化的一瞬间做出反应. 在程序的观察者模式，观察者不需要时刻盯着被观察者,而是采用注册或者称为订阅的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我 同时我们也可以多个观察者对应一个被观察者
其实在android中也有很多自带的观察者模式。最明显的莫过于点击事件。说个最简单的例子，点击按钮后弹一个Toast。那么，我们在点击按钮的时候，告知系统，此时，我需要弹一个吐司。那么就这么弹出来了。那么，这个时候问题来了。我是否需要实时去监听这个按钮呢？答案是不需要的。这就和前面的举例有的差距了。换句话说。我只要在此按钮进行点击时进行监听就可以了。这种操作被称为订阅。也就是说Button通过setOnClickListener对OnclickListener进行了订阅了操作，来监听onclick方法。
基本使用 rxjava的基本实现主要是三点：
初始化 Observable （被观察者） 初始化 Observe（观察者） 建立两者之间的订阅关系 创建Observable Observable&amp;lt;String&amp;gt; observable = Observable.create(new ObservableOnSubscribe&amp;lt;String&amp;gt;() { @Override public void subscribe(ObservableEmitter&amp;lt;String&amp;gt; e) throws Exception { e.onNext(&amp;#34;hello world&amp;#34;); e.onComplete(); //调用complete后下面将不再接受事件 } }); 创建Observe Observer&amp;lt;String&amp;gt;observer=new Observer&amp;lt;String&amp;gt;() { @Override public void onSubscribe(Disposable d) { Log.i(&amp;#34;rxjava&amp;#34;, &amp;#34;onSubscribe: &amp;#34; + d); } @Override public void onNext(String string) { Log.i(&amp;#34;rxjava&amp;#34;, &amp;#34;onNext: &amp;#34; + string); } @Override public void onError(Throwable e) { Log.</description>
    </item>
    
    <item>
      <title>Android Activity生命周期</title>
      <link>https://magren.cn/android-life-cycle/</link>
      <pubDate>Fri, 06 Mar 2020 14:36:01 +0000</pubDate>
      
      <guid>https://magren.cn/android-life-cycle/</guid>
      <description>先上Google提供的经典图，是对Activity生命周期各个阶段之间导航转换的直观展现。
Activity类提供了六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop()和onDestroy()。
生命周期 说明 在正常的情况下，Activity从启动到结束会按以下的顺序经历整个生命周期：onCreate()-&amp;gt;onStart()-&amp;gt;onResume()-&amp;gt;onPause()-&amp;gt;onStop()-&amp;gt;onDestory()。 onCreate():系统首次创建Activity的时候触发，可以做一些初始化的工作，比如初始化Activity所需要的数据，还有调用setContentView加载界面布局资源。 onRestart()：表示Activity正在重新启动。一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。这种情形一般是用户行为导致的，比如用户按Home键切换到桌面或打开了另一个新的Activity，接着用户又回到了这个Actvity。 onStart(): 表示Activity正在被启动，即将开始，这时Activity已经出现了，**但是还没有出现在前台，无法与用户交互。**这个时候可以理解为Activity已经显示出来，但是我们还看不到。 onResume():表示Activity已经可见了，并且出现在前台并开始活动。需要和onStart()对比，onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。 onPause():表示 Activity正在停止，仍可见，正常情况下，紧接着onStop就会被调，onPause中不能进行耗时操作，会影响到新Activity的显示。因为onPause必须执行完，新的Activity的onResume才会执行。 onStop():表示Activity即将停止，不可见，位于后台。可以做稍微重量级的回收工作，同样不能太耗时。 onDestory():表示Activity即将销毁，这是Activity生命周期的最后一个回调，可以做一些回收工作和最终的资源回收。 几种普遍情况 从A页面Activity跳转到B页面Activity，然后关闭B页面Activity，回到A页面Activity 针对开启的B页面Activity，第一次启动，回调如下：onCreate()-&amp;gt;onStart()-&amp;gt;onResume() 用户打开B页面Activiy的时候，A页面的Activity处于不可见的回调如下：onPause()-&amp;gt;onStop() 再次从B页面回到A页面原Activity时，A页面从不可见到可见回调如下：onRestart()-&amp;gt;onStart()-&amp;gt;onResume() 按back键回退时，B页面Activity回调如下：onPause()-&amp;gt;onStop()-&amp;gt;onDestory() 按Home键切换到桌面后又回到A页面该Actitivy，回调如下：onPause()-&amp;gt;onStop()-&amp;gt;onRestart()-&amp;gt;onStart()-&amp;gt;onResume() 调用finish()方法后，回调如下：onDestory()(以在onCreate()方法中调用为例，不同方法中回调不同，通常都是在onCreate()方法中调用) Activity的三种运行状态 Resumed（活动状态） 又叫Running状态，这个Activity正在屏幕上显示，并且有用户焦点。这个很好理解，就是用户正在操作的那个界面。
Paused（暂停状态） 这是一个比较不常见的状态。这个Activity在屏幕上是可见的，但是并不是在屏幕最前端的那个Activity。比如有另一个非全屏或者透明的Activity是Resumed状态，没有完全遮盖这个Activity。
Stopped（停止状态） 当Activity完全不可见时，此时Activity还在后台运行，仍然在内存中保留Activity的状态，并不是完全销毁。这个也很好理解，当跳转的另外一个界面，之前的界面还在后台，按回退按钮还会恢复原来的状态，大部分软件在打开的时候，直接按Home键，并不会关闭它，此时的Activity就是Stopped状态。
部分流程分支 启动Activity: onCreate()—&amp;gt;onStart()—&amp;gt;onResume()，Activity进入运行状态。 Activity退居后台: 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—&amp;gt;onStop()，进入停滞状态。 Activity返回前台: onRestart()—&amp;gt;onStart()—&amp;gt;onResume()，再次回到运行状态。 Activity退居后台，且系统内存不足， 系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–&amp;gt;onStart()—&amp;gt;onResume()(将重新走一次Activity的初始化生命周期) 锁屏：onPause()-&amp;gt;onStop() 解锁：onStart()-&amp;gt;onResume() 横竖屏下切换 第一种情况，销毁当前的Activity： 在横竖屏切换的过程中，Activity会先销毁后重建，也应该避免这种情况。 这里有两个回调：
onSaveInstanceState和onRestoreInstanceState。 在Activity由于异常情况下终止时，系统会调用onSaveInstanceState来保存当前Activity的状态。这个方法的调用是在onStop之前，它和onPause没有既定的时序关系，该方法只在Activity被异常终止的情况下调用。当异常终止的Activity被重建以后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象参数同时传递给onRestoreInstanceState和onCreate方法。因此，可以通过onRestoreInstanceState方法来恢复Activity的状态，该方法的调用时机是在onStart之后。其中onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别： onRestoreInstanceState回调则表明其中Bundle对象非空，不用加非空判断。onCreate需要非空判断。建议使用onRestoreInstanceState。 简单来说，这个过程Activity的生命周期为：onPause()-&amp;gt;onSaveInstanceState()-&amp;gt; onStop()-&amp;gt;onDestroy()-&amp;gt;onCreate()-&amp;gt;onStart()-&amp;gt;onRestoreInstanceState-&amp;gt;onResume() 第二种情况，当前的Activity 不销毁，但是我们需要设置Activity的属性： 可以通过在AndroidManifest文件的Activity中指定如下属性：
&amp;lt;activity android:name=&amp;#34;.activity.VideoDetailActivity&amp;#34; android:configChanges=&amp;#34;orientation|keyboardHidden|screenSize&amp;#34; android:screenOrientation=&amp;#34;portrait&amp;#34;/&amp;gt; 通过回调下面的方法，避免横竖屏切换的时候Activity的销毁和重建：
@Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); } 当资源不足的时候，保留Activity的优先级顺序： 前台Activity——正在和用户交互的Activity，优先级最高。 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户交互。 后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。 </description>
    </item>
    
    <item>
      <title>说说Android的内存泄露和溢出</title>
      <link>https://magren.cn/android-memory/</link>
      <pubDate>Sun, 01 Mar 2020 14:27:13 +0000</pubDate>
      
      <guid>https://magren.cn/android-memory/</guid>
      <description>虽然在大学以来学习了一年多的安卓，已经可以完成一部分的需求，但是在Android这方面的底层知识和一些概念我应该不算非常了解，借着这个长假的机会打算好好熟悉下。
Android内存泄漏 内存泄漏是指保存了不可能再被访问的变量引用，导致垃圾回收器无法回收内存。 也就是说： 在Java中有些对象的生命周期是有限的，当它们完成了特定的逻辑后会被回收，但是，如果在对象的生命周期本该被回收时，这个对象仍然还被别的对象所持有引用，那么就会导致内存泄漏。 具体例子：
public class LeakAct extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); } public void test() { new Thread(new Runnable() { @Override public void run() { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }z } }).start(); } } test是一个非静态内部类，当我们finish的时候，该实例不会真正销毁，GC机制也不会进行该实例的垃圾回收，因为***匿名内部类和非静态内部类持有外部类的强引用， ***也就是说test持有外部activity的强引用，而thread内部while(true)是死循环，线程不会停止，对外部activity的强引用也不会消失。这样就造成了内存泄漏。
解决方案
1.将内部类变成静态内部类; 2.如果有强引用Activity中的属性，则将该属性的引用方式改为弱引用; 3.在业务允许的情况下，当Activity执行onDestory时，结束这些耗时任务;
Android内存溢出 内存溢出指的是APP向系统申请超过最大阀值的内存请求，系统不会再分配多余的空间，从而造成内存溢出
典型的例子就是加载多张大图，导致内存耗尽，可以对图片进行适当的质量压缩或者尺寸压缩。 当某个界面存在内存泄露，反复进入该界面，将导致一直有新对象创建但是无法回收，最终导致内存耗尽，造成内存溢出。 </description>
    </item>
    
    <item>
      <title>关于starTranslation</title>
      <link>https://magren.cn/about-star-translation/</link>
      <pubDate>Mon, 03 Feb 2020 16:16:20 +0000</pubDate>
      
      <guid>https://magren.cn/about-star-translation/</guid>
      <description>&lt;p&gt;这个项目其实去年就有写了，但是那时候没有用到基类，然后用的是网易云有道翻译的sdk，耦合方面也不是做的很好，在寒假这段时间便把它重构了一遍，
同时用上了rxjava2和retorfit来进行网络的请求以及用上了ButterKnife。这个项目就当作自己的一个学习吧，后面还有什么可以优化的地方再逐步更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;附上项目地址：&lt;a class=&#34;link&#34; href=&#34;https://github.com/Magren0321/starTranslation&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;starTranslation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>Android基类的设计</title>
      <link>https://magren.cn/android-base-class/</link>
      <pubDate>Thu, 09 Jan 2020 16:16:20 +0000</pubDate>
      
      <guid>https://magren.cn/android-base-class/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这两天开始放寒假，在家呆着也是呆着，遂决定找星空以前Android方向大佬写的项目学习下，看看别人代码的结构以及有什么方法可以降低代码的耦合度，然后在师兄的项目里接触到了BaseActivity，在这里记录一下&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
  </channel>
</rss>
