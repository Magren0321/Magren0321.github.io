[{"content":"博客不知不觉就写一年了。 试着对自己过去一年进行一个复盘，就像瑞·达利欧所说的：\n 生活中的大多数东西都不过是「同类情况的重演」。\n 得学着从过去中汲取经验。\n2020 健康  无论啥时候健康总是首位，1月中旬的时候终于把横在身体里三年的两根钢板拆掉了，熬过来了后想想好像也没什么，虽然当时好像痛的很厉害😅 疫情返校后有在学校里断断续续地跑步，最长的一次不停地跑了八公里🏃 后面也有买瑜伽垫来做俯卧撑+仰卧起坐+深蹲。  可惜以上的项目随着考试月的到来以及天气降温全部停掉了🐷\n \nCode  继续学习着Vue和小程序，稍微看了一点点的node.js，但是都不算精。 前不久买了本JavaScript高级程序设计看，希望能在这个假期里面啃完。 也在试着用自己新学到的东西去敲点小东西出来，除了学到东西外更多的是给我带来了一些成就感。  学习就是要静下心来，好好沉淀（然而还是很菜）。🎯\n设备  入了个茶轴的Anne pro2，60%布局+蓝牙真的让我体验到了无线的便利以及轻巧。 当全世界在讨论2077的时候我才购入了动物森友会，跟着她一块岛建中。 买了零件亲自给5s更换电池以及排线，梦回高中。   \n \n感情 突然就一年多了。 越来越了解彼此， 这一年里一起去了挺多地方，也在一起努力着 还是希望能好好的一直在一块🌟\n \n日常 日常就是折腾。\n疫情在家想给电脑加多根内存条，心血来潮想换换硅脂，结果拧螺丝拧上头导致风扇的一颗螺丝拧花了取不下来。 祸不单行，电脑的电源也坏了……遂又买了电源自己换。\n前不久考试那段时间电脑开机以及读取机械硬盘里的数据非常慢，甚至直接卡死……重装系统等各种操作才排查出来是我的机械硬盘坏了，遂拆掉去网上买了个固态，又是突然的心血来潮给自己电脑装了个Ubuntu，但是用不惯，一天后就换回来了。\n这台电脑从windows-\u0026gt;macos-\u0026gt;windows-\u0026gt;ubuntu-\u0026gt;windows，真的是玩了个遍。\n2021 出行 疫情期间+封校让这一年的出行基本都泡汤了，希望明年能多出去走走，见识见识。 对于不怎么学校的我，先不说出省了，能把广州好玩的地方逛完就不错了。🤔\n 逛遍广州  能力  学习React和Angular 啃掉JavaScript高级程序设计、深入浅出node.js等书籍 做些新东西，为开源做贡献  健康  养成锻炼的习惯 给我早睡！  生活  培养一门新的特长  最后 2020虽然充满遗憾，但还是要充满对生活的热情。人间值得，未来可期。 遗憾会是惊喜的序曲。\n \n","date":"2020-12-31T20:17:01Z","image":"https://magren.cn/2020%E9%81%97%E6%86%BE%E6%98%AF%E6%83%8A%E5%96%9C%E7%9A%84%E5%BA%8F%E6%9B%B2/2020final_hu43edec84879d041a8e90779a22103c7d_187386_120x120_fill_q75_box_smart1.jpg","permalink":"https://magren.cn/2020%E9%81%97%E6%86%BE%E6%98%AF%E6%83%8A%E5%96%9C%E7%9A%84%E5%BA%8F%E6%9B%B2/","title":"2020，遗憾是惊喜的序曲"},{"content":"我是少数派的一个读者，成为少数派已经419天。\n从少数派里面学到了很多东西，也丰富了自己的眼界，所以少数派APP也是我手机上的常用应用之一，在去年将手机换成了Android后，发现到现在为止Android的APP已经很久没有更新过了，Android客户端一直处于一个“年久失修”的状态，反倒是IOS的一直在更新迭代，更新了UI以及一些新的功能，这让我十分眼红。\n但是在少数派3月31号发布的文章中，他们为Android客户端做出了一个解释，并且提出了一个更优解。\n 继去年少数派网站改版升级后，更符合新版设计的少数派 iOS 客户端 2.0 也在不久前正式上线。可惜由于开发能力实在有限，Android 平台繁杂的机型适配和兼容性问题也着实令人头疼，少数派的 Android 客户端此前一直处于「年久失修」的状态。\n好在少数派最终为 Android 客户端找到了一个「更优解」——渐进式网页应用（以下简称 PWA）。在保证内容呈现完整的前提下，PWA 有着比客户端应用更轻量、比网页版功能更强大的全新体验，同时还能兼容 Android、iOS 甚至 Windows 等多个平台。\n 关于PWA这个概念我是第一次知道，抱着新奇的态度开始Google……\n关于PWA PWA 是 Google 于 2016 年提出的概念，于 2017 年正式落地，于 2018 年迎来重大突破，全球顶级的浏览器厂商，Google、Microsoft、Apple 已经全数宣布支持 PWA 技术。\nPWA 全称为 Progressive Web App，中文译为渐进式 Web APP，其目的是通过各种 Web 技术实现与原生 App 相近的用户体验。\n纵观现有 Web 应用与原生应用的对比差距，如离线缓存、沉浸式体验等等，可以通过已经实现的 Web 技术去弥补这些差距，最终达到与原生应用相近的用户体验效果。\n好吧说完上面的官方发言，地道一点说下我自己的体验，就是一个Web页面拿掉了浏览器的壳子，以一个近似app的形式存在手机桌面，与一般的将网页添加到桌面不同，它还有本地通知的能力以及一个缓存的能力，除此以外它可以兼容Android、IOS以及Windows多个平台，对我来说它在打开的时候还有一个页面logo闪屏，很有吸引力。\n将自己的博客变成PWA 在体验过少数派的PWA后，我萌生了能否把自己的博客变成PWA的想法，在网上查询了资料后发现入门意外的简单，接下来说说我自己的操作。\n添加 manifest.json 这里新建一个manifest.json文件，主要是配置应用图标以及名称等信息，然后这里分享下我的配置，具体的配置介绍可以参考下MDN。\n{ \u0026#34;dir\u0026#34;: \u0026#34;ltr\u0026#34;, //指定名称、短名称和描述成员的主文本方向  \u0026#34;lang\u0026#34;: \u0026#34;zh-cn\u0026#34;, //语言  \u0026#34;name\u0026#34;: \u0026#34;Magren\u0026#39;s Blog\u0026#34;, //名字  \u0026#34;short_name\u0026#34;: \u0026#34;Magren\u0026#39;s Blog\u0026#34;, //短名称  \u0026#34;theme_color\u0026#34;: \u0026#34;#ffffff\u0026#34;, //主题颜色  \u0026#34;background_color\u0026#34;: \u0026#34;#d4d4d4\u0026#34;, //启动时闪屏的背景颜色  \u0026#34;display\u0026#34;: \u0026#34;standalone\u0026#34;, //定义开发人员对Web应用程序的首选显示模式。  \u0026#34;start_url\u0026#34;: \u0026#34;./index.html\u0026#34;, //开始加载的url  \u0026#34;icons\u0026#34;: [ //程序图标  { \u0026#34;src\u0026#34;: \u0026#34;avatar152.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;152x152\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;avatar192.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;192x192\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;avatar384.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;384x384\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; }, { \u0026#34;src\u0026#34;: \u0026#34;avatar512.png\u0026#34;, \u0026#34;sizes\u0026#34;: \u0026#34;512x512\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;image/png\u0026#34; } ], \u0026#34;splash_pages\u0026#34;: null } 接着就要在我们的HTML文件中引入啦，如果你也是博客的话就去翻翻你的主题文件夹，在里面找下吧。\n\u0026lt;link rel=\u0026#34;manifest\u0026#34; href=\u0026#34;manifest.json\u0026#34; /\u0026gt; 添加 Service Worker 这个API是用来实现页面缓存和离线，还有后台通知，不过因为这就是我的一个个人博客，所以我没有加上通知的功能。\n首先判断浏览器是否支持serviceWorker，如果支持则调用函数来注册站点的service worker，service worker 只是一个驻留在我们的 app 内的一个 JavaScript 文件。\n在html的页面下加上：\n\u0026lt;script\u0026gt; if (\u0026#39;serviceWorker\u0026#39; in navigator) { window.addEventListener(\u0026#39;load\u0026#39;, function () { navigator.serviceWorker.register(\u0026#39;/sw.js\u0026#39;, {scope: \u0026#39;/\u0026#39;}) .then(function (registration) { // 注册成功  console.log(\u0026#39;ServiceWorker registration successful\u0026#39;); }) .catch(function (err) { // 注册失败:(  console.log(\u0026#39;ServiceWorker registration failed\u0026#39;); }); }); } \u0026lt;/script\u0026gt; 接着是sw.js，即我们的serviceWorker，这里可以定义需要缓存的路径, 以及需要缓存的静态文件的列表, 这个列表也可以通过 Webpack 插件生成，我这里就只缓存了首页。\n//监听service worker事件 self.addEventListener(\u0026#39;install\u0026#39;, function (event) { var homePage = new Request(\u0026#39;index.html\u0026#39;); event.waitUntil( //请求首页并将首页存入缓存  fetch(homePage).then(function (response) { //建立cache-homePage缓存  return caches.open(\u0026#39;cache-homePage\u0026#39;).then(function (cache) { return cache.put(homePage, response); }); })); }); //请求页面 self.addEventListener(\u0026#39;fetch\u0026#39;, function (event) { event.respondWith( fetch(event.request).catch(function (error) { //请求失败，从缓存中读取缓存的页面  return caches.open(\u0026#39;cache-homePage\u0026#39;).then(function (cache) { return cache.match(\u0026#39;index.html\u0026#39;); }); })); }); //刷新首页 self.addEventListener(\u0026#39;refreshHomePage\u0026#39;, function (response) { return caches.open(\u0026#39;cache-homePage\u0026#39;).then(function (cache) { //将刷新后的页面缓存  return cache.put(offlinePage, response); }); }); 最后 最后说说如何使用pwa吧，在手机上，只需通过支持的浏览器（如 Chrome以及小米自带的浏览器）访问 PWA 页面地址，Chrome会在加载完页面后弹出添加页面的提示，如果没有的话（如IOS的Safari），需要手动点击浏览器的更多，然后直接添加到桌面上即可。\nPC端的话Chrome的右上角（网页链接的最右端）有一个下载按钮，点击后就会添加到电脑桌面。如果要卸载的话只是删除电脑桌面的快捷方式是不可以的，需要打开来然后在PWA页面的上方点击卸载按钮。   \n","date":"2021-04-03T22:14:21+08:00","image":"https://magren.cn/%E5%B0%86%E5%8D%9A%E5%AE%A2%E5%8F%98%E6%88%90pwa/pwa_huf7420ce1a337e90ec18894b72ee0bcce_33680_120x120_fill_box_smart1_2.png","permalink":"https://magren.cn/%E5%B0%86%E5%8D%9A%E5%AE%A2%E5%8F%98%E6%88%90pwa/","title":"将博客变成PWA"},{"content":"21岁  达成成就：与第三旋臂边缘的一颗蓝色星球上的碳基生物一起度过了该行星在所在恒星系内的二十一次公转。\n 老实说，从20岁开始我对自己生日这件事的态度已经由激动转为了焦虑。\n20岁前我盼望着快点长大，憧憬外面的生活，不想拘泥于当下，但是20岁开始，接触了外面的社会，焦虑工作以及自己一事无成，很多事想做好也用力去做好，但是结果还是差强人意。\n焦虑归焦虑，该来的会来，该做的还是该做，稍作整理后，我也接受了这种状态。即使没有以前那么热血以及饱含精力，也还是要热爱自己从事的事业，做好自己该做的事，珍惜眼前人。\n认清自己 很喜欢罗振宇老师说的一句话: 成长就是你的理想世界碰到了现实世界，掉进去了叫做挫折，爬出来了叫做成长。\n在以前我就常常自命不凡，认为自己的人生一定得轰轰烈烈，甚至纠结过清华北大（现在只能仰望），随着年龄增长也开始慢慢认知到了自己的瓶颈和各方面的极限，也渐渐清楚了自己的渺小，但是这种较负面的自我认知导致我失去了部分的信心，不敢轻易地去做尝试，妄自菲薄，对于一些事情也可以说是用自暴自弃的态度去对待，认为自己是绝对做不好的，于是也曾逃避过，以至于我现在时常都在遗憾。\n魔兽世界中，如果在达拉然许愿池钓鱼，会钓上很多金币银币铜币，其中一枚叫“安东尼达斯的银币”，上面写着：“请赐予我力量，去接受我所不能改变的；请赐予我勇气，去改变我所能改变的；并赐予我智慧去分辨两者的不同。＂\n其实最为关键的是分辨两者的智慧，如果有这一种智慧能以绝对的态度告诉我这件事情我可以做出改变，那么我想我也会打起十二分的信心去做这件事，可是智慧是抽象的，亦没有一个准确的标准，所以我觉得这份智慧得以另一种方式来替代——认知。\n很多事情没能如愿其实都是因为没有一个正确的认知，对工作周期的认知，对自身能力的认知，对周边资源的认知……人们也常常因为懒惰而对一件事情早早的定下结论，这样可以省去一个复杂的探讨过程，但是往往会导致一个错误的行为。\n清楚的自我认知对我来说是一件困难的事，常常我会因他人的评价，旁人的观点而动摇自己，我自身没有那么强大的心脏，他人泼的冷水，说的一些他认为不上心的话，对我来说却要花较长的时间去消化并且重新振作；我自身也非常容易自满，他人一点好的评价都会使我飘飘然。所以在做一件我没有十足把握的事的时候我都尽量避免让他人知道，没有耳旁风的时候我更能清楚的认识自己。\n在21年里我都在逐渐的了解自己，与自己和解，希望这也是一种成长。\n做一个有趣的人 我一直想做一个幽默有趣的人，我认为能让别人打从心里发笑是一种非常伟大的力量。\n但是我指的幽默并不是指的一个人的接梗能力或者说一些网络热词的能力，就比如说一个人玩游戏玩的很厉害的时候，就说他6；一个人远投三分穿针了也说他6；久而久之6这个数字就会让我审美疲劳，甚至这个热词给滥用在各种事上，导致了这个词或者这个梗的质量下降。\n更可怕的是当时间久了我发现6这个数字已经取代了我脑子里原本许多存在的词语，在对待朋友的时候6这个词也成了脑子里第一出现的词，称赞只会666。无疑我缺少了部分独立思考的能力，这也导致了我一些真实的想法没有说出口。\n独立思考以及自己独特的见解应该是有趣的前提，希望自己能够以自己的眼睛去观察世界并思考。\n心怀感激 虽然21岁伴随着许多遗憾，但是也有许多可爱的人陪伴在身边，这样让我感受到我是被爱着的，光是这样就足够扫除阴霾了。谢谢一直陪伴着我的家人以及朋友。\n今年的生日是宝可梦主题！\n 生活明朗，万物可爱，人间值得，未来可期。\n  \n \n \n","date":"2021-03-21T14:00:21+08:00","image":"https://magren.cn/%E5%86%99%E5%9C%A8%E8%87%AA%E5%B7%B121%E5%B2%81%E7%94%9F%E6%97%A5/birthday_hua718cbcddd74e448ca4668c189e4828b_97984_120x120_fill_box_smart1_2.png","permalink":"https://magren.cn/%E5%86%99%E5%9C%A8%E8%87%AA%E5%B7%B121%E5%B2%81%E7%94%9F%E6%97%A5/","title":"写在自己21岁生日"},{"content":"这一阵子迷上了像素风格，很有复古的味道，加上小时候玩宝可梦的时候还是像素风格，牵扯出了太多情怀。\n甚至把自己的电脑壁纸也换成了像素风。很有感觉😝  \n想自己在像素风上创作，但是感觉自己是没有那种艺术细胞……所以就在想，能不能自己把一张正常的图片转换成像素风？🤔\n思路⭐  使用canvas将图片缩小，使其丢失部分像素信息 再将缩小的图片绘制出来 将缩小的图片放大，使能看到其像素点  其实就是小的图片放大，会感觉到糊的效果。\nCode💻 禁止浏览器的平滑处理其实就是是否抗锯齿。\n用正则表达式限制输入框只能输入0-100，意味着让图片缩放的百分比（100就是没有缩放，达不到像素化的效果）\nconst pixel = (canvas, image, scale)=\u0026gt; { scale *= 0.01; canvas.width = image.width; canvas.height = image.height; // 将图片缩小  let scaledW = canvas.width * scale; let scaledH = canvas.height * scale; let ctx = canvas.getContext(\u0026#39;2d\u0026#39;); // 禁止浏览器的平滑处理  ctx.imageSmoothingEnabled = false; ctx.mozImageSmoothingEnabled = false; ctx.webkitImageSmoothingEnabled = false; ctx.msImageSmoothingEnabled = false; //将缩小后的图片绘制出来  ctx.drawImage(image, 0, 0, scaledW, scaledH); //将缩小后的图片还原到原来的大小  ctx.drawImage(canvas, 0, 0, scaledW, scaledH, 0, 0, canvas.width, canvas.height); }; btn.addEventListener(\u0026#39;click\u0026#39;, function(){ const Regex = new RegExp(/^100$|^(\\d|[1-9]\\d)(\\.\\d+)*$/) let scale = input.value; if(scale==\u0026#39;\u0026#39;){ scale = 40; } if(!Regex.test(scale)){ window.alert(\u0026#39;输入不规范\u0026#39;) return; } console.log(scale); pixel(canvas,img,scale); }, false); 效果👇  \n","date":"2021-02-25T16:33:21+08:00","image":"https://magren.cn/%E4%BB%A3%E7%A0%81%E5%B8%AE%E6%88%91%E7%94%BB%E5%83%8F%E7%B4%A0%E7%94%BB/banner_hud3cc57fa5673d3672539d26f50f40c0d_44156_120x120_fill_box_smart1_2.png","permalink":"https://magren.cn/%E4%BB%A3%E7%A0%81%E5%B8%AE%E6%88%91%E7%94%BB%E5%83%8F%E7%B4%A0%E7%94%BB/","title":"代码帮我画像素画"},{"content":"学习新东西👋 最近这几天在学习React，所以这个项目主要目的是给我熟悉React，我个人是喜欢边学习一样新东西边动手，只有输出才会让我记忆更深刻，其次也会踩到一些光看是不会碰到的坑，加上之前学习node.js好像也没有做什么，于是就想到了结合在一块做一个聊天室。✌\n因为是第一次做React，如果觉得有什么需要修改的欢迎提出Issuse，也欢迎你的star⭐\n项目地址：ChatRoom\n项目截图：  \n \n \n后端 后端基于Node.js + Express + Socket.io + MongoDB\nNode.js操作MongoDB以及用express写接口之前都有在博客中大致的总结过：\nNode.js+express\nNode.Js操作MongoDB\n这次用的新东西就是Socket.io。\n前人的工作👇  Socket.IO is a library that enables real-time, bidirectional and event-based communication between the browser and the server\n 即是说Socket.io可以实现服务器与客户端之间的一个实时的双向通信。\n在连接Socket.io的之前还得先知道WebSocket，在WebSocket问世之前，在创建拥有双向通信机制的 web 应用程序时，就只能利用 HTTP 轮询的方式，由此产生了 “短轮询” 和 “长轮询”。\n 短轮询通过客户端定期轮询来询问服务端是否有新的信息产生，缺点也是显而易见，轮询间隔大了则信息不够实时，轮询间隔过小又会消耗过多的流量，增加服务器的负担。\n长轮询是对短轮询的优化，需要服务端做相应的修改来支持。但是每次请求还是都要带上HTTP请求头部，而且在长轮询的连接结束之后，服务器端积累的新消息要等到下次客户端连接时才能传递。\n Websocket协议就是为了解决长轮询的痛点而诞生的，其基于TCP协议，是一种双全工通信技术、复用HTTP握手通道。它与HTTP协议的唯一关系就是它的握手请求可以作为一个Upgrade request经由HTTP服务器解析，且与HTTP使用一样的端口。\n接着是Socket.io，Socket.io底层基于engine.io，封装了WebSocket，其屏蔽了底层细节，让顶层调用非常简单。同时它还支持许多种轮询机制以及其他通信方式，当环境不支持WebSocket的时候它能自动选择最佳的方式来实现网络的实时通信。\n使用 引入io设置端口后监听connect事件：\nconst server = require(\u0026#39;http\u0026#39;).Server(app); const io = require(\u0026#39;socket.io\u0026#39;)(server); server.listen(3001); //端口设置3001  io.on((\u0026#39;connection\u0026#39;, socket=\u0026gt;{ ……………… }) 接着通过最重要的两个api，emit和on来发送以及监听事件\n socket.emit(eventName,[ \u0026hellip;args])：发射（触发）一个事件 socket.on(eventName, callback)：监听一个 emit 发射的事件  //监听xxx事件，输出传进来的data对象 socket.on(\u0026#39;xxx\u0026#39;,data=\u0026gt;{ console.log(data); }) //发送xxx事件，传出去一个对象，里面有name属性 socket.emit(\u0026#39;xxx\u0026#39;,{name:\u0026#39;magren\u0026#39;}) 另外用到的方法\n socket.join(id)：加入到一个room为id的房间中 socket.broadcast.to(id).emit( )：广播给room为id的除了‘我’以外的所有人 io.sockets.in(id).emit( )：广播给room为id的所有人  前端 前端基于React + Redux + Typescript + Antd\n向后台发送消息以及监听很简单，只需要引入socket.io-client，接着使用emit发送和on监听事件即可。\nconst socket = require(\u0026#39;socket.io-client\u0026#39;)(\u0026#39;ws://localhost:3001\u0026#39;,{transports: [\u0026#39;websocket\u0026#39;]}) //监听信息 socket.on(\u0026#39;chat_message\u0026#39;,(data: mesItem)=\u0026gt;{ this.setState({ message:[data,...this.state.message] }); }) //发送加入群组 socket.emit(\u0026#39;join\u0026#39;, { roomId:this.props.match.params.roomId, userName:this.props.state.name, userId:this.props.state.id }) //发送信息 socket.emit(\u0026#39;mes\u0026#39;,{ roomId:this.props.match.params.roomId, userName:this.props.state.name, userId:this.props.state.id, mes:this.state.msg }) 关于Redux redux跟vuex的理念给我的感觉是一样的，同样都是一个状态管理库，并且都是保存在内存当中（刷新就会重置），定义全局state，触发后修改state。不同的地方也还是有的，Vuex的数据是可变可直接修改，Redux不可变并且是直接用新的state替换掉旧的state。\n这个项目用了 react-redux 和 redux-thunk 两个库。\n使用了react-redux后流程大大缩短，store的三大功能：dispatch，subscribe，getState都让它来帮我们实现了，同时它提供了Provider和Connect，前者是一个组件，后者是一个函数。\n大致的流程就是Provider组件接受redux的store作为props，然后通过context往下传，connect函数收到Provider传出的store，并将state和actionCreator以props传入组件，组件就可以通过调用props里的action触发reducer函数返回新的state，connect监听到变化后调用setState更新组件并将新的state传入。\nredux-thunk的作用：可以让 store.dispatch 变成可以接收一个函数/一个对象的中间件。\n 让原本只能接受对象的 store.dispatch 变成可以接收对象/方法，并且如果接收了一个方法后自动执行该方法，而不触发 redux 的 store 更新。\n 最后💻 感谢Google、baidu等搜索引擎和Google翻译😵\n以及bailicangdu大佬的react-pxq项目的参考以及总结😘\n","date":"2021-02-10T18:11:21+08:00","image":"https://magren.cn/%E5%85%B3%E4%BA%8Echatroom/chatRoom_huc88acfaa844eb1f39ff9adc202a02393_142793_120x120_fill_box_smart1_2.png","permalink":"https://magren.cn/%E5%85%B3%E4%BA%8Echatroom/","title":"关于ChatRoom"},{"content":"前言 这个项目是我某天在宿舍听歌想到的，从16年注册网易云到现在都有五年的时间了，虽然这个平台现在越来越让我失望，但是听了五年了都听出感情来了，就在这个假期里面花了将近一个月磨磨蹭蹭写出来这个项目。至于为什么写的是移动端页面嘛，是因为那时候我听歌是用着我的手机听的……所以模仿的UI也是安卓版网易云音乐的UI。虽然功能没有全部实现，但是比较核心的播放页面还是做出来了，这篇博客也是记录一下这个项目的至今的实现过程还有一些坑。\n项目基于Vue + Typescript + Vuetify UI实现。\n项目地址：CloudMusic\n已经实现的功能：\n 登录 获取歌单 创建歌单 删除/取消收藏歌单 播放歌曲 排行榜 每日推荐 推荐歌单  项目截图：    \n  \n播放 这个可以说是核心功能，毕竟一个听歌的平台不能听歌就说不过去了。\n首先歌曲的选择可以来自歌单，可以来自发现页的轮播图，还可以来自播放页面的选择，然后控制歌曲的播放暂停既可以从其他页面下方的播放tab控制，又可以在播放的页面进行控制，如果使用Prop和Emit实在是太多太乱了，所以我这里使用了Vuex。\n Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n 其实就是把我们需要的组件共享状态抽取出来，以一个全局单例模式管理，然后我们可以在任何一个组件下通过Vuex来修改其状态或者值。\n于是我将所选的歌曲ID，以及当前播放的歌单信息，ID传进了Vuex，在播放页面只需要监听Vuex中歌曲id的变化，即可播放新的歌曲；监听Vuex中是否暂停的状态，来控制audio组件暂停或者播放。\n播放进度 进度条我用的是Vuetify UI中的slider组件，通过v-model来设定其值。\n在audio中通过 @timeupdate 来监听audio当前的播放时间戳，接着与播放总时长相除并乘以100得到当前播放进度的百分比，接着赋值给slider组件即可，进度条左边的时间也是通过当前播放的时间戳转换成的时间。\n但是这里会有个问题，就是需要通过移动滑块来修改播放的进度，在刚刚@timeupdate绑定的方法中只是单向的将进度赋值给滑块，并且在音乐播放的时候这个方法是一直在运行的，这样无论我怎样移动滑块，滑块都会立马就瞬移到了当前的播放位置，所以这里还得加一个监听是否正在移动滑块的方法，当移动滑块的时候不将当前播放的进度赋值给滑块，然后当我松手的时候将滑块当前的进度转换成时间戳赋值回给audio的播放时间。\n我的解决办法是给滑块组件引入了 @mousedown 和 @mouseup，当鼠标按下的时候将一个变量赋值为true，抬起的时候为false，修改@timeupdate中的方法，设定其只有在该变量为false的时候才会对滑块组件赋值，但是滑动滑块的时候也得修改当前的播放时间，所以给滑块组件引入了 @change ，当手动更改了滑块的值的时候会触发该方法，在这个方法里面对audio的播放进度进行修改。\n \n歌词实现 从后台获取的歌词是一个字符串，但是每行歌词都用了\\n标识，所以将字符串以\\n分割可以得到每行的歌词，每行歌词里中括号里面的是时间，还得将每句歌词以中括号进行分割，最后将时间转换成时间戳，与歌词放在一块做为一个类放入数组中。\n设置一个索引，用于记录是第几行歌词，通过offsetHeight获取到歌词组件的高度来确认歌词中线所在的位置，通过索引乘以每行歌词的高度来判断是否滚动。\n其实就是给外部的div设置超出隐藏，然后通过修改mragin-top来实现一个滚动的效果，而margin-top的值是由中线的高度减去索引乘以每行歌词的高度来决定。同时可以通过transition属性来设定其改变的时间。\n例如：transition: margin-top 1s;\n表示的就是说margin-top属性会在一秒内完成。\n关于Vue的自定义指令 在制作的过程中我想实现个功能就是点击某个组件以外的位置的时候隐藏该组件，即点击的不是该组件的时候会执行一个方法。\n我查资料的时候发现vue并没有这么一个指令，但是我可以通过自己去自定义这么一个指令来实现这个功能。\n首先看看一个自定义的指令对象的钩子函数：\n bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下) componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind：只调用一次，指令与元素解绑时调用。  接着钩子函数中都有以下几个参数：\n el：指令所绑定的元素，可以用来直接操作 DOM。 binding：一个对象，包含以下 property：  name：指令名，不包括 v- 前缀。 value：指令的绑定值，例如：v-my-directive=\u0026ldquo;1 + 1\u0026rdquo; 中，绑定值为 2。 oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression：字符串形式的指令表达式。例如 v-my-directive=\u0026ldquo;1 + 1\u0026rdquo; 中，表达式为 \u0026ldquo;1 + 1\u0026rdquo;。 arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 \u0026ldquo;foo\u0026rdquo;。 modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。   vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用  以上都是来自Vue的文档，虽然有那么多的钩子函数和变量但是都是可选的，只选需要用到的即可。在实现这个功能中我也就只用到了bind和unbind，其中的变量也是只用到了el和binding。\nimport {DirectiveOptions} from \u0026#34;vue\u0026#34;; //自定义指令clickoutside，当点击的不是当前元素的时候执行绑定的方法 const clickoutside: DirectiveOptions = { // 初始化指令  bind (el: any, binding: any, vnode) { function documentHandler (e: any) { // 这里判断点击的元素是否是本身，是本身，则返回  if (el.contains(e.target)) { return false } // 判断指令中是否绑定了函数  if (binding.expression) { // 如果绑定了函数 则调用那个函数  binding.value(e) } } // 给当前元素绑定个私有变量，方便在unbind中可以解除事件监听  el.vueClickOutside = documentHandler document.addEventListener(\u0026#39;click\u0026#39;, documentHandler) }, unbind (el: any, binding) { // 解除事件监听  document.removeEventListener(\u0026#39;click\u0026#39;, el.vueClickOutside) delete el.vueClickOutside } } export default clickoutside; 在需要的地方引入：\n@Component({ directives:{ clickoutside, } }) 使用(当点击的不是该div的时候调用outside方法)：\n\u0026lt;div v-clickoutside=\u0026#34;outside\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 当我把这个东西实现了不久后我发现Vuetify已经集成了这么一个指令，我可以直接使用，这就是不好好看文档的下场。\n最后⭐️ 🙏 感谢由 网易云音乐api 提供的接口以及文档。\n以及这个项目是个人学习而制作，正常使用还请到网易云音乐👈\n","date":"2021-01-28T16:33:21+08:00","image":"https://magren.cn/%E5%85%B3%E4%BA%8Ecloudmusic/banner_hu0ea77f992d92db75b170bc4f02a95d6f_316874_120x120_fill_box_smart1_2.png","permalink":"https://magren.cn/%E5%85%B3%E4%BA%8Ecloudmusic/","title":"关于CloudMusic"},{"content":"先说说为啥要迁移 在这之前用的是hexo + next主题，然后自己心血来潮加了网易云的外链还有live 2d，tag cloud这些东西，也有人说过挺好看的，但是自己看多了就觉得有点花里胡哨，而且当我在网上查阅东西进到别人博客的时候，看到的基本都是hexo + next……有点审美疲劳。\n但也很容易理解，hexo比较容易上手而且比较稳定，有着功能齐全并且成熟的主题（说的就是Next），这个时候我的眼光放到了hugo上。\nHugo 依靠Go语言进行开发，并且号称世界上最快的构建网站工具，究竟有多快我也不知道，但是我用hexo生成静态网页的时候还需要等，用hugo就没有等过，给我的感觉就是我敲完命令回车的那一刻他就好了……\n另一方面就是hugo支持热加载，在文件修改的内容支持实时地显示在网页上，比起hexo需要点多下刷新来说，还是比较方便的。\nhugo虽然有着上述说的优点，但是hugo在知名度上不及hexo，教程还有资料，以及优化配置这些方面在网上相比hexo来说都是比较少的，所以有些东西还得自己慢慢摸索。\n搭建 环境   Git\n  由于hugo依靠go语言，所以还得装Go\n  接着装hugo\nhugo 解压完后只需要将其添加到环境变量中即可。\n  生成博客 hugo 安装完后可以用命令行运行 hugo new site \u0026lsquo;博客名字\u0026rsquo; ，这样hugo会生成一个用于存放博客的文件夹，里面一般有：\n archetypes/ content/ data/ themes/ layouts/ static/ config.toml  一般的配置信息写在 config.toml里面，文章以及一些页面在content里面，archetypes 里面一般放的是使用 hugo new 生成页面的时候头部配置信息格式。themes里面放的是你需要的主题。\n主题安装 跟hexo不同，hugo没有自带的主题，所以这个时候运行hugo serve来浏览的时候是一片空白的，所以这个时候我们得去hugo官网主题库里去找喜欢的主题。\n同时按照主题给的文档在config.toml里面进行配置，一般下载下来的主题文件夹里有一个exampleSite的文件夹，那是作者的配置示例，如果不知道配置什么的话可以复制作者的示例，然后自行修改即可。\n生成博文 使用hugo new posts/xxxx.md 命令，可以使content/posts文件夹中生成你需要的 markdown 文件，用markdown语法编辑即可。\n还有要注意的就是新生成的文件上方与hexo不同的是多了一条 draft属性，这是表示是否是草稿，假如是true的话该文件不会渲染成页面，更不会在博客中显示，删掉或者改成false便会渲染了。\n添加tag和categories的方法跟hexo是一样的。\n生成页面 特别的页面（archives页面等）可以使用 hugo new page/xxx.md生成，例如about页面就 hugo new page/about.md，生成后将draft删掉后添加一条layout属性，表明他是什么页面，about页面的话就layout: about。\n浏览以及部署 浏览的话用hugo serve命令，然后地址为 http://localhost:1313/，与hexo略有不同。\n执行hugo命令生成静态页面，然后博客的文件夹下会多了一个public文件夹，这个文件夹下就是最后生成的页面，将public文件夹中的文件push到仓库中就好了。\n最后 从长远角度看的话，写的博文越多hugo的优势越明显。\n但其实我只是想弄来玩玩而已。\nJust for fun。\n","date":"2021-01-08T14:54:21+08:00","image":"https://magren.cn/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3hugo/hugo_hu2dfce353afad633eac4f777d88bb92f7_62258_120x120_fill_box_smart1_2.png","permalink":"https://magren.cn/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E8%87%B3hugo/","title":"博客迁移至Hugo"},{"content":"最近在准备着前端的面试，这个问题基本是必考题，稍微去网上查阅了一些资料，并且自己整理了下。\n总的过程如下：\n 输入URL DNS解析 建立TCP链接 发送HTTP请求 服务器永久重定向 服务器处理请求并返回一个HTTP响应 浏览器显示HTML 链接结束  输入URL URL的中文名叫统一资源定位符，用于得到资源的位置和访问方法。 其组成为：协议：//主机名:端口号/路径/;参数?查询#信息片段\nDNS解析 DNS（域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，得到主机名对应的IP地址的过程就叫做域名解析。 DNS解析的过程其实就是为了寻找哪台机器上有需要的资源，实际上充当了一个翻译的身份，将输入的网址转换成IP地址。 以下是DNS的一个查找顺序：\n 浏览器缓存：向浏览器缓存中读取访问记录 操作系统缓存：查找在系统运行内存中的缓存 host文件：查找本地硬盘的host文件 路由器缓存：部分路由器会缓存访问过的域名 ISP（互联网服务提供商）DNS缓存：在本地查找不到的情况下，ISP会在当前服务器的缓存中查找 根DNS服务器：根域名收到请求，判断是哪台服务器管理，并返回顶级DNS服务器的IP给请求者。  在查找完以后本地DNS服务器向域名的解析服务器发起请求，本地服务器将IP地址返回给电脑，并将对应关系保存在缓存中。\n拓展： DNS的查询方式：\n 递归：局部DNS服务器负责向其他DNS服务器查询（一般先向该域名的根域服务器查询，接着一级一级向下查询），结果返回给局部DNS服务器后再由其返回个客户端。 迭代：局部DNS服务器把能解析该域名的其他DNS服务器的IP地址给客户端DNS程序，再由该程序向这些DNS服务器查询（用于局部DNS服务器不能回答客户机DNS查询时）。  DNS优化方法：\n DNS缓存 DNS负载均衡  为啥需要：当每次请求的资源都在同一台机器上时，机器可能承受不过来而崩掉。 原理：为一个主机名配置多个IP地址，在应答查询饿时候对每个查询以DNS文件中记录的IP地址按顺序返回不同的结果，将访问引导到不同的机器上去。    建立TCP链接 拿到IP地址后就是通过三次握手来建立TCP链接了。\n 第一次握手：客户端发送SYN（同步序列编号）包到服务器，并且进入SYN_SENT状态，等待服务器确认。 第二次握手：服务器收到SYN包后确认，同时自己也发送一个SYN包，即SYN+ACK包，服务器进入SYN_RECE状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送一个确认包ACK，发送完毕后客户端和服务器进入ESTABLISHED状态。  拓展： 为啥三次握手：为了防止已经失效的链接请求报文突然传送到了服务端因而产生错误。\n发送HTTP请求 建立TCP连接后客户端发起HTTP请求，HTTP报文包含三个部分：\n 请求行：请求方法+URL+协议/版本 请求报头：传递请求的附加信息和客户端自身的信息 请求正文：需要传递的数据  服务器永久重定向 服务器给浏览器响应一个301永久重定向响应，例如访问http://google.com/ 会自动跳转到 http://www.google.com/\n目的：\n 这样就会把访问带www的和不带www的地址归到同一个网站排名下，网站在搜索链接的排名下就不会降低。 用不同的地址会导致缓存的良好性变差，一个页面有多个名字的时候可能会在缓存中出现多次。  服务器处理请求并且返回HTTP报文 后端从固定的端口接收到TCP报文后，会对TCP进行处理，对HTTP协议进行解析，按照报文格式进一步封装成HTTP Request对象，供上层使用。 HTTP响应由4个部分组成：\n 状态行：协议版本、状态代码、状态描述 响应头：由键值对组成，每行一对，用“:”分割 空行： 分割请求数据 响应正文  拓展： 在大一点的网站中会将请求到反向代理中，将同一应用部署到多台服务器上，将大量用户请求分配给多台机器处理。 即客户端先请求到Nginx，Nginx再请求应用服务器，最后将结果返回客户端。\n浏览器显示HTML 浏览器显示HTMl是一个边解析边渲染的过程，大致的过程为：\n 解析HTML文件构建DOM树 解析CSS文件构建渲染树 浏览器开始布局渲染树并将其绘制到屏幕上  拓展： 关于reflow(回流)和repaint(重绘)：\n DOM节点中的各个元素都是以盒模型的形式存在，浏览器计算其位置、大小等属性的这个过程称之为reflow。 当这些属性都确定下来后，浏览器开始绘制内容，这个绘制的过程称之为repaint。  reflow和repaint在页面首次加载的时候是肯定要经历的，但是这两个过程都是十分消耗性能，应该尽可能减少。 js解析以及执行机制： 当解析过程中遇到JS文件时，HTML文档会挂起渲染的线程，然后等待js文件加载并且解析完毕（由于js有可能会修改DOM，例如document.write），故平时js代码也是放在html的末尾。 js解析是由浏览器中的js解析引擎完成，js是单线程运行，但是像IO读写等任务比较耗时，所以需要一种机制可以先执行排在后面的任务，即同步任务和异步任务。 js的执行机制可以看做成一个主线程+一个任务队列。 同步任务是放在主线程上的任务，在主线程上形成一个栈； 异步任务是放在任务队列中的任务，有了运行结果就会在任务队列中放置一个事件； 脚本先运行栈，然后从任务队列中提取事件，运行里面的任务。 这个过程不断循环，也被称为事件循环。\n链接结束 现在页面为了优化请求耗时，一般都会持续着TCP的链接，而TCP链接断开的时机是当前页面关闭的时候。 接下来就是四次挥手断开TCP链接：\n 主机发送一个FIN，主机进入FIN_WAIT_1状态。 服务端收到FIN后，发送一个ACK给主机，确认序号为收到序号+1，服务端进入CLOSE_WAIT状态。 服务端发送一个FIN报文，用来关闭数据传送，并且进入LAST_ACK状态。 主机收到FIN后，进入TIME_WAIT状态，接着发送一个ACK给服务端，确保服务端收到自己的ACK报文后进入CLOSED状态  ","date":"2020-11-08T23:12:57Z","permalink":"https://magren.cn/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA/","title":"从输入URL到页面展示"},{"content":"前一段时间学习了node.js操作mongoDB数据库，现在追加一篇写接口的记录。\n链接数据库 在项目根目录下安装Mongoose\n npm install mongoose \u0026ndash;save\n 利用mongoose来链接MongoDB 在项目中创建db.js文件：\n\u0026#39;use strict\u0026#39;; import mongoose from \u0026#39;mongoose\u0026#39;; mongoose.connect(\u0026#39;mongodb://localhost:27017/test\u0026#39;, { useNewUrlParser: true, useUnifiedTopology: true }); const db = mongoose.connection; db.once(\u0026#39;open\u0026#39; ,() =\u0026gt; { console.log( \u0026#39;连接数据库成功\u0026#39; ); }) db.on(\u0026#39;error\u0026#39;, function(error) { console.error( \u0026#39;Error in MongoDb connection: \u0026#39; + error ); mongoose.disconnect(); }); db.on(\u0026#39;close\u0026#39;, function() { console.log( \u0026#39;数据库断开，重新连接数据库\u0026#39; ); }); export default db; 创建数据模型（建一张表） 在test数据库中创建一张名为StudentSchema的表，表中有name和age字段，并且公出。\nimport mongoose from \u0026#39;mongoose\u0026#39;; //创建schema const StudentSchema = new mongoose.Schema({ name: String, age: Number }) const studentSchema = mongoose.model(\u0026#34;StudentSchema\u0026#34;,StudentSchema); export default studentSchema; 接口路由搭建 添加body-parser依赖:\n npm install body-parser\n 在app.js中引入：\nimport bodyParser from \u0026#39;body-parser\u0026#39;; //使用body-parser中间件 app.use(bodyParser.urlencoded({extended:false})); app.use(bodyParser.json()); 新建一个js文件，用于写数据接口 req.body指的是URL中的参数，req.params指的是路径\nimport express from \u0026#39;express\u0026#39;; import studentInfo from \u0026#39;./studentInfo\u0026#39;; const router = express.Router(); router.get(\u0026#34;/test\u0026#34;,(req,res)=\u0026gt;{ res.json({msg:\u0026#34;接收成功\u0026#34;}); //示例：http://localhost:3000/test }) //添加一条数据 router.post(\u0026#39;/add\u0026#39;,(req,res) =\u0026gt; { const Student = {}; if(req.body.name){ Student.name = req.body.name; } if(req.body.age){ Student.age = req.body.age; } new studentInfo(Student).save().then(user =\u0026gt; { res.json(user); }); }) //根据id删除一条数据 router.post(\u0026#39;/delete\u0026#39;,(req,res) =\u0026gt; { studentInfo.remove({_id:req.body.id}).then((result)=\u0026gt;{ res.json(result) }) }) //获取一条数据 router.get(\u0026#39;/:id\u0026#39;,(req,res) =\u0026gt; { studentInfo.findOne({_id:req.params.id}).then(user =\u0026gt; { if(!user) { return res.status(400).json(\u0026#34;没有任何数据存在\u0026#34;) } return res.json(user) }).catch(err =\u0026gt; { return res.status(404).json(err) }) }) //更新一条数据 router.post(\u0026#39;/:id\u0026#39;,(req,res) =\u0026gt; { const Student = {}; if(req.body.name){ Student.name = req.body.name; } if(req.body.age){ Student.age = req.body.age; } studentInfo.updateOne({ _id: req.params.id }, { $set: Student }).then(user =\u0026gt; { if (!user) { return res.status(400).json(\u0026#34;数据不存在\u0026#34;); } res.json(user); }) .catch(err =\u0026gt; { return res.status(404).json(err); }); }) module.exports = router; 使用 在app.js中引入：\nimport test from \u0026#39;./test\u0026#39;; app.use(test); 利用Postman测试 POST测试： 将POST的body设置成x-www-form-urlencoded，下图为更新数据的接口示例：  更新数据 \nGET测试： 下图为根据ID获取一条数据的示例  \n","date":"2020-10-19T23:17:34Z","permalink":"https://magren.cn/node.js-express%E5%86%99%E6%8E%A5%E5%8F%A3/","title":"node.js+express写接口"},{"content":"大学期间最值得分享的事情我想就是星空了吧，\n贯彻了我大学生活的一半，也是我程序员道路上的启蒙。\n也留下来过想将星空在前两年带给我的技术还有启发去回馈给星空，希望能延续下去，让下一代有更好的资源。 但是当选择一条路的时候，根本无法预知它的曲折程度。 梳理了一下自己在星空这两年多的历程，也是写了个流水账，是为了能够记录这段非常宝贵的时光，也是希望对后辈以及一些迷茫和踌躇的朋友有一些帮助。\n两年前 在校级组织招新摆摊的那天晚上，抱着 看小姐姐 凑热闹的想法走进了人堆， 推掉了学生会的了解邀请，躲掉了学生志愿者， 但是没躲掉星空， 星空也是当时摆摊招新的组织里头唯一一个做互联网技术这一块的，抱着学习的想法，一头扎进了这个充满活力的地方。 经过两次简单的培训还有两次考核后成功的挤进了星空，成为了从两百多个学生里面留下来的三十个人中的一个，当时还是挺自豪的。（仍然记得每次快到考核结果发布的时候就看着手机坐立不安）\n进来互相认识不久后就开展了素拓，由于学校的限制我们这一届的素拓就成了在学校里玩游戏， 我的师兄跟我说星空的素拓都被称之为脱单素拓（但我就没见过在素拓里脱单的。） 看我还在犹豫，他跟我说\n 师兄：其他中心的人也会参加哦，别的中心挺多小姐姐的。\n  我：我星空服穿好了，什么时候出发？\n 当时我还觉得都是大学生了，在学校里面跑跑跳跳玩小游戏有什么意思？ 但是最后我们那组是玩的最嗨的一队，甚至拿了奖，是一箱的小零食hhhhhhhhh。\n快乐过后接踵而至的就是每周晚自习的任务还有来自谢峰善意的嘲讽。\n “你看看你”（指猪）\n  “你写的代码都是啥”\n  “你加任务！”\n 可恶，以后成大佬了一定要怼回去。\n一旦埋下改变的种子，机会就会随着你的念头悄然出现\n那一段时间真的是在野蛮生长。 从每周一天的晚自习主动申请成了每周两天都去。 做着师兄下发的任务，一边疯狂谷歌百度，然后就认识了Gihub、stackoverflow、CSDN等平台。 大一上学期的时候学校教的也是C，不是Java，所以那时候一边学C一边学Java。 虽然很累，但是很充实，每解决一个BUG每实现一个功能，都知道自己前进了一步。 星训营虽然熬夜敲代码敲得很晚，做成的东西也不算好，但是有一个功能基本实现的产品展示在大家面前的时候还是很有成就感。\n夏训营还有冬训营的时候都不是很想留下，虽然就是考完期末考在学校呆一周，每天都去办公室学习。 但估计是考完试了心就飘了，就想要放松下。 可最后我还是被我的副总监强制安排留了下来，他还骗我说他也在，结果每次都没见到过他。 可恶，给算计了。 但是不得不承认这期间学到的东西是挺多的，博客这个领域也是当时的to在分享会上让我有所了解。 主要是大家都在学习，我就不好意思玩。\n踏上星空的舞台，抓住每个机会，跟志同道合的朋友一起做热爱的事情，不停地成长自我，真的很酷。\n一年前 回到学校的第一件正事就是招新， 说实话跟陌生人打交道这回事应该大部分程序员都不太会，估计是常年跟计算机打交道，成了一个闷骚的性格。 反观传媒那边的人络绎不绝，几乎有新生走过来第一个想了解的都是摄影、视频，让技术小哥们都很眼红。 小知估摸也看不下去了，疯狂的催我们去揽人，估计是怕星空的技术就断在我们手上了吧hhhhh。\n面试的时候看着一批批紧张的大一感觉颇有意思，当初我在师兄师姐眼中应该也是这样的吧， 嫩雏内敛，但是充满希望和活力。 但是当大三大四那几个老油条走进来的时候我就傻眼了。有内鬼，终止交易 我寻思着他们的发际线也不像大一的啊，这也能装？\n笔试的最后一题是问：你认为程序员都是怎样的一群人？ 加葱在答题的地方画了个画，画了几个在一块小人，然后上面画了几个星星，左上角画太阳右上角画月亮，两个还用双箭头连在了一块，下面有电脑，写了个code。 我们看到那简笔画的时候都想笑，毕竟知道他是来捣乱的，那自然也要顺一下他的意思，就问他是什么意思。\n 啊，我觉得程序员就是，跟好朋友一起，在同一片星空下，从白天到黑夜都一起努力敲代码学习。\n 直到现在我也还是觉得，这不仅是对程序员的诠释，也是对星空最好的诠释。我的心中对星空有了个很明确的答案。\n因为一些原因，我需要去补上CTO这个职位，但是估计是因为当时的我对星空的发展没有什么好的见解，也并不清楚CTO这个职位是要去承担什么，所以当时校团委的老师是认为我太过稚嫩了吧，不过也不得不承认这的确是我自身能力的问题，事后也好好反思了自己，仅有胆魄但是没有能力是做不成什么事的，格局还有眼界也别局限。\n尔后就是培养新进来的六个小星星，他们比我大一的时候要有潜力多了，学的也很快，甚至有一个在进来之前就已经有过开发的经验，后浪后浪，后生可畏。 后辈的成长也是给我带来了压力，我希望能让他们这一年里在这个方向上学到更多的东西，所以我也没停下自己的脚步，也是机缘巧合下看到了晓特的博客，阿里巴巴大佬的博客，应该有点宝可以掏吧？ 事实证明是真有点东西，但是不仅是技术，还有星空。 从他文章里的字里行间我窥探着以前的星空，窥探着隔了几年时间的星空， 坐上抽屉的时光机，跟这个素不相识的人进行了一场交流，从他的嘴里听当年星空的故事。 感觉还是很奇妙，看着一篇故事，而此刻自己就在经历这么一场故事。\n当时也有在思索着自己在过去一年学到的东西能否做出什么来反哺给星空，可惜最后都无疾而终，成了个遗憾，反倒是学习前端的路上折腾出来的小玩意上线了，无心插柳柳成荫吧。\n成了管理层会变得很累，除了自身技术的学习以外还多了很多的琐事，跟其他方向的同事也有很多意见不合的时候，但是在思想的碰撞时也能学到一点东西，而且看着那几个小兔崽子一边做着我加的任务一边骂我的时候，还是很开心的。\n折腾永无止境，在星空的舞台上就要去利用星空的资源，去做出自己想做出的东西，去丰富自己，这不仅是个人的成长，也是相互成就。\n现在 为响应学校推行的组织改革，作为校级组织的星空就要结束了。 我应该是第一批知道这个消息的人吧， 9月4日上午进行了校级组织的会议，正式告知了我们这个消息， 9月4日下午，我一个人在办公室逛了几圈，对这个充满故事和活力的地方默默地道别。 往后我们开了管理层的会议，也拉了各中心的小星星开会，最后得出了我们要走的路。 星空学生创新中心准备转型成为一个工作室。\n不过既然选择要遵循内心，那就要做好最坏的打算\n在后面的一个月里我东奔西跑，问了计院的老师，也问了师兄师姐，不仅工作室的成立，也问了创业园的入住方式，最后都没有一个很好的结果，后面也渐渐看开。 晓特也说过： 胜则举杯相庆，败则拼死相救，众志成城，万事可成。人心涣散，做什么也没用 倘若大家都愿意去行动起来，我想很多问题都将不是问题，行动力才是解决问题的重点。\n再往后的事，就不是个定数了，希望星空的小伙伴们依然能抱着一份热情去积极地实现自己想实现的事。\n做好当下，方有未来。\n 那一年我们望着星空 有那么多的灿烂的梦\n有那么多的灿烂的梦\n至少回忆会永久\n像不变星空\n陪着我\n最后只剩下星空\n像不变回忆\n陪着我\n  \n以上就是一个星空退休老人家在星空两年的故事，希望这段真实的故事能对在看的你有一点价值。 起风了，我也该走了。\n","date":"2020-10-14T00:25:54Z","image":"https://magren.cn/%E9%82%A3%E4%B8%80%E7%89%87%E7%92%80%E7%92%A8%E8%80%80%E7%9C%BC%E7%9A%84%E6%98%9F%E7%A9%BA/xingkongLogo_hu72a858400279ece4d0568c268eddf5d5_84867_120x120_fill_q75_box_smart1.jpg","permalink":"https://magren.cn/%E9%82%A3%E4%B8%80%E7%89%87%E7%92%80%E7%92%A8%E8%80%80%E7%9C%BC%E7%9A%84%E6%98%9F%E7%A9%BA/","title":"那一片璀璨耀眼的星空"},{"content":"EventBus是用于Vue中组件通信的一种方式，常见的父子组件沟通方式有emit和props。\n但假如跨组件传参沟通，或者是兄弟姐妹组件之间的传参沟通，使用EventBus或者Vuex就可以避免很多重复的props和emit。\nVuex适合的场景是中大型的项目，管理全站共用的状态。EventBus比较适用于小型的项目，不是太复杂的事件。\n使用 EventBus实际上只是一个Vue的实例，接着分别调用这个实例的事件触发和监听来实现通信和参数传递。主要是下面四种方法：\n $on：注册监听 $once：监听一次 $off：取消监听 $emit：发送事件  一般页面created的時候就注册监听，当组件销毁时取消监听。\n创建一个EventBus 其实就是创建一个Vue的实例\nimport Vue from \u0026#39;vue\u0026#39;; // 使用 Event Bus const bus = new Vue(); export default bus; 在我们需要发送事件以及接收事件的组件中引入。\nimport bus from \u0026#39;../common/bus\u0026#39;; 监听 在需要监听的组件中的created中使用bus监听\ncreated() { bus.$on(\u0026#39;getSomething\u0026#39;, target =\u0026gt; { console.log(target); }); } 发送事件 methods: { // 把事件 emit 出去  doSomething(target) { bus.$emit(\u0026#34;getSomething\u0026#34;, target); } } 取消监听 EventBus的监听不会自动关闭，接着会导致的一个情况就是监听会触发多次，所以需要我们用$off取消下绑定。 通常绑定在钩子函数 beforeDestroy() 或者 destroyed() 中\n// 移除事件的监听 bus.$off(\u0026#39;getSomething\u0026#39;) // 移除所有事件的监听 bus.$off() ","date":"2020-10-12T11:21:03Z","permalink":"https://magren.cn/vue%E4%B8%8B%E7%9A%84eventbus/","title":"Vue下的EventBus"},{"content":"最近开学事情逐渐多了起来，星空、康课还有学校的课程……一切都开始逐渐步入正轨，唯独我的学习之路还在跑偏。\n经常会停下来不知道学什么，也提不起动力学，担心自己学的东西派不上用场，也担心自己半途而废。\n也难怪有万事开头难这种说法了。\n但是一旦行动起来，忙起来的时候就会感到充实。只要动起来，无论结果怎样，都总比没有尝试过的好。\n但行好事，莫问前程\n我也纠结过是学习用node.js还是Java去操作后端数据库。 有的人说学node.js，前端工程师都要会这个；也有的人说学java，去学ssm，学spring全家桶；还有的人说node.js没有前途； 最后在网上看到了一个答案， 他说：程序员本身不该受语言的约束，更不该受框架的约束。什么样的场景用什么样的工具。 所谓的没有前途一直都是错误的使用正确的工具。 你得有一颗拿c++造宇宙飞船的心。🚀\nnode.js是什么？ 根据官方的说法：\n Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.\n Node.js 就是一個能执行 JavaScript 的环境，而 V8 则是主流浏览器 - Google Chrome 的 JavaScript 引擎，负责、执行 JavaScript。 Node.js再加上一系列的c/c++套件，成功的让我们的服务器端也可以执行JavaScript。\n环境安装 node.js安装 下载地址：Node.js官网下载\nMongoDB数据库 下载地址：MongoDB官网下载\n启动服务 在MongoDB文件夹下的bin目录下用命令行输入：.\\mongo 来启动服务\n可视化工具 Robo3T 用于可视化操作MongoDB数据库，下载地址：Robo3T\nexpress Express 是一个简洁而灵活的 node.js Web应用框架, 提供了一系列强大特性帮助你创建各种 Web 应用，和丰富的 HTTP 工具。\nexpress脚手架 express脚手架安装：\n npm install -g express-generator\n 创建express项目：\n express test\n  cd test\n  npm install\n 运行：\n npm start\n 浏览器访问：\n http://localhost:3000/\n express脚手架引入babel 引入babel是为了转译 ECMAScript 2015+ 至可兼容浏览器的版本，说白了就是为了让我们使用ES6。\n依赖 修改后记得执行npm install以更新依赖包。\n{ \u0026#34;name\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.0\u0026#34;, \u0026#34;private\u0026#34;: true, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;node ./index.js\u0026#34;, \u0026#34;devstart\u0026#34;: \u0026#34;nodemon ./index.js\u0026#34; }, \u0026#34;dependencies\u0026#34;: { \u0026#34;babel\u0026#34;: \u0026#34;^6.23.0\u0026#34;, \u0026#34;babel-cli\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;babel-core\u0026#34;: \u0026#34;^6.24.0\u0026#34;, \u0026#34;babel-preset-es2015\u0026#34;: \u0026#34;^6.24.0\u0026#34;, \u0026#34;babel-preset-stage-3\u0026#34;: \u0026#34;^6.22.0\u0026#34;, \u0026#34;babel-register\u0026#34;: \u0026#34;^6.24.0\u0026#34;, \u0026#34;cookie-parser\u0026#34;: \u0026#34;~1.4.4\u0026#34;, \u0026#34;debug\u0026#34;: \u0026#34;~2.6.9\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;~4.16.1\u0026#34;, \u0026#34;http-errors\u0026#34;: \u0026#34;~1.6.3\u0026#34;, \u0026#34;jade\u0026#34;: \u0026#34;~1.11.0\u0026#34;, \u0026#34;mongoose\u0026#34;: \u0026#34;^5.10.5\u0026#34;, \u0026#34;morgan\u0026#34;: \u0026#34;~1.9.1\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;babel-plugin-transform-async-to-generator\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;babel-plugin-transform-es2015-classes\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;babel-plugin-transform-es2015-modules-commonjs\u0026#34;: \u0026#34;^6.24.1\u0026#34;, \u0026#34;babel-plugin-transform-export-extensions\u0026#34;: \u0026#34;^6.22.0\u0026#34; } } 新建.babelrc于根目录 文件代码如下：\n{ \u0026#34;presets\u0026#34;: [\u0026#34;stage-3\u0026#34;], \u0026#34;plugins\u0026#34;: [ \u0026#34;transform-async-to-generator\u0026#34;, \u0026#34;transform-es2015-modules-commonjs\u0026#34;, \u0026#34;transform-export-extensions\u0026#34; ] } 新建index.js于根目录 文件代码如下：\nrequire(\u0026#39;babel-core/register\u0026#39;); require(\u0026#39;./bin/www\u0026#39;); 此时语法支持import等es6语法。\nnode.js操作MongoDB数据库 依赖 在项目根目录下安装Mongoose\n npm install mongoose \u0026ndash;save\n 链接数据库 利用mongoose来链接MongoDB 在项目中创建db.js文件：\n\u0026#39;use strict\u0026#39;; import mongoose from \u0026#39;mongoose\u0026#39;; mongoose.connect(\u0026#39;mongodb://localhost:27017/test\u0026#39;, { useNewUrlParser: true }); const db = mongoose.connection; db.once(\u0026#39;open\u0026#39; ,() =\u0026gt; { console.log( \u0026#39;连接数据库成功\u0026#39; ); }) db.on(\u0026#39;error\u0026#39;, function(error) { console.error( \u0026#39;Error in MongoDb connection: \u0026#39; + error ); mongoose.disconnect(); }); db.on(\u0026#39;close\u0026#39;, function() { console.log( \u0026#39;数据库断开，重新连接数据库\u0026#39; ); }); export default db; 接着在app.js中引入\nimport db from './mongodb/db'; 这个时候运行项目会在MongoDB中创建一个test的库，但是由于里面没有数据所以并不会显示出来。\n添加数据 //引入模块 import mongoose from \u0026#39;mongoose\u0026#39;; import db from \u0026#39;./mongodb/db\u0026#39;; // 创建schema // schema是MongoDB里的一个集合，也可以说是库中的一张表 let testSchema = new mongoose.Schema({ name: String, age: Number }) // 通过connection和schema创建model let testModel = connection.model(\u0026#39;test1\u0026#39;, testSchema); // 通过实例化model创建文档 let test = new testModel({ name: \u0026#39;Magren\u0026#39;, age: 20 }) // 将文档插入到数据库，save方法返回一个Promise对象。 test.save().then((doc) =\u0026gt; { console.log(doc) }) 添加成功后MongoDB数据库里会多了test1这么一个表，同时表中会多了一条name为Magren，age为20的数据。\n读取数据 //引入模块 import mongoose from \u0026#39;mongoose\u0026#39;; import db from \u0026#39;./mongodb/db\u0026#39;; let testSchema = new mongoose.Schema({ name: String, age: Number }) let testModel = connection.model(\u0026#39;test1\u0026#39;, testSchema); //查询条件，查询name为Magren的记录，格式为键值对 //查询条件为空的时候即查询该表中的全部数据 testModel.find({name: \u0026#39;Magren\u0026#39;}).then(doc =\u0026gt; { console.log(doc); }) 为了复用代码，降低耦合度，一般将Schema以及Model模块的代码单独出来。\n更新数据 //引入模块 import mongoose from \u0026#39;mongoose\u0026#39;; import db from \u0026#39;./mongodb/db\u0026#39;; let testSchema = new mongoose.Schema({ name: String, age: Number }) let testModel = connection.model(\u0026#39;test1\u0026#39;, testSchema); //第一个参数是查询条件，找到name为Magren这条数据 //第二个参数是要修改的值 testModel.updateMany({name: \u0026#39;Magren\u0026#39;},{age: 18}).then((result)=\u0026gt;{ console.log(result) }) 删除数据 //引入模块 import mongoose from \u0026#39;mongoose\u0026#39;; import db from \u0026#39;./mongodb/db\u0026#39;; let testSchema = new mongoose.Schema({ name: String, age: Number }) let testModel = connection.model(\u0026#39;test1\u0026#39;, testSchema); //删除name为Magren的数据 testModel.removeMany({name: \u0026#39;Magren\u0026#39;}).then((result)=\u0026gt;{ console.log(result) }) 最后 现在只是学习了基本的node.js对MongoDB数据库的操作，改天尝试做一个小项目，部署到服务器上，感觉又会踩很多坑…… 但如果没有实践也只是纸上谈兵，加紧自己学习的脚步吧。 毕竟都已经大三了啊。✊\n","date":"2020-09-16T23:26:09Z","permalink":"https://magren.cn/node.js-mongodb/","title":"node.js + MongoDB"},{"content":"无聊刷知乎的时候发现了一个前端设计的宝藏网站awwwards，对上面大佬实现的网站表示望洋兴叹，\n但同时自己也跃跃欲试，我也想整一个，万一整出来了呢。\n在上面看到了Rally大佬写的GlobeKit,感觉是通过监听滚动事件来进行一个样式的切换，便去了解了一下如何监听页面的滚动事件。\npc端鼠标滚动监听 监听 根据不同的浏览器，在mounted中给页面添加一个滚动监听事件，其中的scrollFun是监听到滚动时候执行的方法\n// 浏览器兼容  if ((navigator.userAgent.toLowerCase().indexOf(\u0026#34;firefox\u0026#34;) != -1)) { document.addEventListener(\u0026#34;DOMMouseScroll\u0026#34;, this.scrollFun, false) } else if (document.addEventListener) { document.addEventListener(\u0026#34;mousewheel\u0026#34;, this.scrollFun, false) } } 获取滚动事件的信息 通过传递的event对象获取滚动的属性\n//滚动翻页 scrollFun(event: any) { // mousewheel事件中的 “event.wheelDelta” 属性值：返回的如果是正值说明滚轮是向上滚动  // DOMMouseScroll事件中的 “event.detail” 属性值：返回的如果是负值说明滚轮是向上滚动  const delta = event.detail || (-event.wheelDelta); if (delta \u0026gt; 0 ) { // 向下滚动  console.log(\u0026#34;向下滚动\u0026#34;) }else if (delta \u0026lt; 0) { //向上滚动  console.log(\u0026#34;向上滚动\u0026#34;) } } 移动端的touch事件 移动端的上下滚动并不能用上面的方法监听，是因为手机没鼠标吧。 为了实现我想要的效果，我都是直接把滚动条隐藏，然后监听touch事件来自行判断用户是否进行一个上滑下滑的操作。\n touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。 touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。 touchend事件：当手指从屏幕上离开的时候触发。  事件添加 双引号里是调用的方法\n\u0026lt;div id=\u0026#34;main\u0026#34; @touchstart=\u0026#34;touchstart($event)\u0026#34; @touchend=\u0026#34;touchend($event)\u0026#34;\u0026gt; 信息的获取 通过传递的$event对象获取触摸事件的信息 例：\ntouchstart(e: any): void{ this.startY = e.touches[0].pageY //获取触摸点的Y轴坐标 } touchend(e: any): void{ const moveEndY = e.changedTouches[0].pageY //获取松开手时Y轴的坐标  ...... } 这样通过两个坐标的相减，我们通过正负即可判断用户的上下滑动。\n传递过来的对象包括了三个用于跟踪触摸的属性：\n touches：表示当前跟踪的触摸操作的touch对象的数组。 targetTouches：特定于事件目标的Touch对象的数组。 changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。  ","date":"2020-08-27T23:30:42Z","permalink":"https://magren.cn/vue%E4%B8%8B%E7%9B%91%E5%90%AC%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8%E4%BB%A5%E5%8F%8A%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6/","title":"Vue下监听页面滚动以及移动端触摸事件"},{"content":"8月到了，一个莫名其妙的机遇也砸到了脸上，提着行李一个人跑到了广州跟一个毕业的师兄搞创业的项目，怀着点点的不安以及兴奋，迈出离开学校的第一步。\n由于就住在办公室的一间房里，出门即工作，开始了朝五晚九的工作生活，晚上的时候就折腾自己的项目，有点梦回星空时候夏训营的感觉，很累也充实。每天也在掉头发以及烦恼吃什么\n自己写的华广地图给自家eo发了一份玩，结果给征收了，上线成了星空的产品，并且要求再进行完善 😟 想了下干脆给每个地点的marker添加一个点击事件，点击后可以看到该地点的详细介绍，不过每个地方都要图片，放在本地太大了，可能会造成卡顿，遂决定放在服务器上，于是重新看了一遍axios同时自己学着网上的一些教程做了一个封装，并解决了跨域的问题。\n封装axios import axios, { AxiosRequestConfig, AxiosResponse } from \u0026#39;axios\u0026#39; const showStatus = (status: number) =\u0026gt; { let message = \u0026#39;\u0026#39; switch (status) { case 400: message = \u0026#39;请求错误(400)\u0026#39; break case 401: message = \u0026#39;未授权，请重新登录(401)\u0026#39; break case 403: message = \u0026#39;拒绝访问(403)\u0026#39; break case 404: message = \u0026#39;请求出错(404)\u0026#39; break case 408: message = \u0026#39;请求超时(408)\u0026#39; break case 500: message = \u0026#39;服务器错误(500)\u0026#39; break case 501: message = \u0026#39;服务未实现(501)\u0026#39; break case 502: message = \u0026#39;网络错误(502)\u0026#39; break case 503: message = \u0026#39;服务不可用(503)\u0026#39; break case 504: message = \u0026#39;网络超时(504)\u0026#39; break case 505: message = \u0026#39;HTTP版本不受支持(505)\u0026#39; break default: message = `连接出错(${status})!` } return `${message}` } const service = axios.create({ // 联调  baseURL: \u0026#39;https://www.wanandroid.com\u0026#39;, headers: { get: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded;charset=utf-8\u0026#39; }, post: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json;charset=utf-8\u0026#39; } }, // 是否跨站点访问控制请求  withCredentials: true, timeout: 30000, //超时时间  transformRequest: [(data) =\u0026gt; { data = JSON.stringify(data) return data }], validateStatus () { // 使用async-await，处理reject情况较为繁琐，所以全部返回resolve，在业务代码中处理异常  return true }, transformResponse: [(data) =\u0026gt; { if (typeof data === \u0026#39;string\u0026#39; \u0026amp;\u0026amp; data.startsWith(\u0026#39;{\u0026#39;)) { data = JSON.parse(data) } return data }] }) // 请求拦截器 service.interceptors.request.use((config: AxiosRequestConfig) =\u0026gt; { return config }, (error) =\u0026gt; { // 错误抛到业务代码  error.data = {} error.data.msg = \u0026#39;服务器异常\u0026#39; return Promise.resolve(error) }) // 响应拦截器 service.interceptors.response.use((response: AxiosResponse) =\u0026gt; { const status = response.status let msg = \u0026#39;\u0026#39; if (status \u0026lt; 200 || status \u0026gt;= 300) { // 处理http错误，抛到业务代码  msg = showStatus(status) if (typeof response.data === \u0026#39;string\u0026#39;) { response.data = {msg} } else { response.data.msg = msg } } return response }, (error) =\u0026gt; { // 错误抛到业务代码  error.data = {} error.data.msg = \u0026#39;请求超时或服务器异常\u0026#39; return Promise.resolve(error) }) export default service 使用 @Component export default class Home extends Vue{ a = [] getSomeThings(){ return request({ url: \u0026#34;/wxarticle/list/408/1/json\u0026#34;, method:\u0026#39;get\u0026#39; }).then((response)=\u0026gt;{ this.a = response.data.data.datas console.log(this.a) }).catch((error)=\u0026gt;{ console.log(error) }) } mounted(){ this.getSomeThings() } 解决跨域问题 关于什么是跨域之前在ajax上已经了解过了，是由浏览器的同源策略造成的，是浏览器对js施加的安全措施。\naxios解决跨域的思路  我们可以配置一个代理的服务器可以请求另一个服务器中的数据，然后把请求出来的数据返回到我们的代理服务器中，代理服务器再返回数据给我们的客户端，这样我们就可以实现跨域访问数据。\n 配置proxy 在我们的vue.config.js下配置以下内容\nmodule.exports = { devServer: { proxy: { \u0026#39;/api\u0026#39;: { target: \u0026#39;https://www.wanandroid.com\u0026#39;,// 你要请求的后端接口ip+port  changeOrigin: true,// 允许跨域，在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题  ws: true,// 开启webSocket  pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39;,// 替换成target中的地址  } } } } } 配置baseURL 在我们封装的axios文件里将baseURL更改为:’/api’\nconst service = axios.create({ baseURL: \u0026#39;/api\u0026#39;, ………… }) 所以上面两步操作是啥意思呢，其实就是：\n 我们请求/wxarticle/list/408/1/json，就相当于请求了：localhost:8080/api/wxarticle/list/408/1/json， 然后配置的proxy拦截了/api，并把/api以及前面的所有替换成了target的内容， 因此实际请求的url是https://www.wanandroid.com/wxarticle/list/408/1/json 即请求到了我们需要的接口了\n 最后 既然搞明白的差不多了，就上手吧，\n 学校的图片呢？\n  啊？没有啊\n  摄影那一边呢？ 😧\n  他们……也只有一部分…… 😧\n  啊……这…… 😩\n 综上所述，项目目前搁浅中 💢\n","date":"2020-08-12T14:45:50Z","permalink":"https://magren.cn/vue-typescript%E4%B8%8Baxios%E7%9A%84%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/","title":"Vue Typescript下axios的封装和使用"},{"content":"最近都在学习前端的路上缓慢前进，在了解了Vue后就开始学习Typescript，每次学习到新东西的时候都会忍不住用新的东西去做一个自己感兴趣的东西，可能自己觉得这样子很Coooooooooooool！👊\n之前偶然间也看到了吉珠的地图，觉得很优秀，碰巧我们学校没有相关的产品，只有一张画出来图片地图，稍加思索\n 考虑到了便携性，决定放在移动端使用 要可以标示出学校的设施地点 校巴的路线以及上下车地点 要有产品的介绍还有学校的介绍 最好能够看到学校实景  加上自己之前学了vue，便打算结合vue来写，说干就干，起飞！✈️\n然后第一天就翻车在了创建项目上。\n一开始装的Vue的版本是2.x版本，创建新项目的webpack版本是3.6的，使用Typescript的时候会提示需要升级webpack到4.x版本，一开始并没有考虑太多，它提示啥问题就Google啥问题怎么解决（面向搜索引擎编程），大致看了一圈，都是卸载旧版的依赖装新的依赖，同时修改配置，但是他们的教程基本都不一样，唯一一样的地方就是都很复杂，也不知道咋选，就挑了个顺眼的就开始照着写，结果失败了……后面发现Vue3.x版本开始都已经开始适配Typescript了，即创建项目的时候就可以选择是否使用Typescript，同时自动给你配置好……啊这。\n旧版本Vue卸载！\n npm uninstall vue-cli -g\n 最新版本Vue安装！\n npm install -g @vue/cli\n 再来一遍，起飞！✈️\n项目地址：HgMap 地图链接：华广地图\n环境依赖  vue/cli 4.4.6 typescript element-ui：ui组件 vue-class-component：类装饰器 vue-property-decorator：基于 vue 组织里 vue-class-component 所做的拓展 vue2-svg-icon：SVG图标组件 地图资源来自高德地图api  注：由于vue-cli 4版本不自带vue.config.js，故需自行在根目录创建并且配置，否则打包项目会找不到静态资源。\nVue 和 Typescript的使用 前提 script标签加入 : lang=“ts”\n\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; ··· \u0026lt;/script\u0026gt; 创建组件 import { Component, Prop, Vue, Watch } from \u0026#39;vue-property-decorator\u0026#39;; @Component export default class Test extends Vue { } 组件的引入 import Mapmenu from \u0026#39;@/components/Mapmenu.vue\u0026#39; @Component({ components: { Mapmenu } }) data对象 boolean或者string等简单类型typescript会自动识别，不需要告知类型,不然运行的时候它还给我个报错……\nimport { Component, Prop, Vue, Watch } from \u0026#39;vue-property-decorator\u0026#39;; export default class Map extends Vue { map: any = null dialog = false name = \u0026#34;MAGREN\u0026#34; } method 方法 可不用逗号隔开，直接写在export default里，需要注明返回类型\n\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import { Component,Vue,Prop,Emit } from \u0026#39;vue-property-decorator\u0026#39;; import markers from \u0026#39;@/config/markers.ts\u0026#39; @Component export default class Mapmenu extends Vue { show = true // methods  //学校介绍  toPageSchoolInfo(): void{ this.$router.push({ path:\u0026#39;/schoolinfo\u0026#39; }) } ……………… } Prop以及Emit 用于父子组件传参 父组件 :map = \u0026lsquo;map’表示将父组件的map参数传入子组件，并且命名为map。 @show-dialog=“handleChildValue” 表示将子组件传来的值在handleChildValue方法中处理。\n\u0026lt;template\u0026gt; \u0026lt;Mapmenu :map=\u0026#39;map\u0026#39; @show-dialog=\u0026#34;handleChildValue\u0026#34;\u0026gt;\u0026lt;/Mapmenu\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; // @ is an alias to /src import AMap from \u0026#39;@/config/amap.ts\u0026#39; import Mapmenu from \u0026#39;@/components/Mapmenu.vue\u0026#39; import { Component,Vue } from \u0026#39;vue-property-decorator\u0026#39;; @Component({ components: { Mapmenu } }) export default class Map extends Vue { dialog = false …… private handleChildValue(val: boolean) { // val: 子组件传过来的值  this.dialog = val; } } 子组件 调用父组件传过来的参数直接使用this.xxx 需要向父组件传递参数直接调用@Emit注解里的方法。\n\u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; //引入Prop和Emit import { Component,Vue,Prop,Emit } from \u0026#39;vue-property-decorator\u0026#39;; import markers from \u0026#39;@/config/markers.ts\u0026#39; @Component export default class Mapmenu extends Vue { show = true //接收父组件传来的值  @Prop() private map: any //向父组件传值  @Emit() private showDialog(){ return this.show } } 高德地图加载和使用 高德地图加载 封装地图，并通过Promise进行一个异步加载，TypeScript在编译时对window类型做了判断,不允许直接调用window.xx，改成any类型即可使用。加载前先判断是否已经存在。\nexport default function MapLoader(): Promise\u0026lt;void\u0026gt;{ return new Promise((resolve, reject) =\u0026gt; { const win: any = window if (win.AMap) { resolve(win.AMap) } else { const url=\u0026#39;高德地图api\u0026#39; const script: HTMLScriptElement = document.createElement(\u0026#39;script\u0026#39;) script.charset = \u0026#39;utf-8\u0026#39; script.src = url script.onerror = reject document.head.appendChild(script) } win.onLoad = () =\u0026gt; { resolve(win.AMap) } }) } 在需要的地方调用\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script lang=\u0026#34;ts\u0026#34;\u0026gt; import AMap from \u0026#39;@/config/amap.ts\u0026#39; import { Component,Vue } from \u0026#39;vue-property-decorator\u0026#39;; export default class Map extends Vue { map: any = null //初始化地图  async initAMap(): Promise\u0026lt;void\u0026gt; { try { const res: any = await AMap(); this.map = new res.Map(\u0026#34;container\u0026#34;, { //装载在id为container的div  viewMode:\u0026#39;3D\u0026#39;, // 地图模式,手机下只有2d效果  resizeEnable: true, //是否监控地图容器尺寸变化  zoom: 17, //初始化地图层级，  center: [113.172847,23.43399], //初始化地图中心点，  pitch:40, // 地图俯仰角度，有效范围 0 度- 83 度  buildingAnimation:true, //3d地图显示动画  }); this.personOptions(this.map,true) }catch (err) { console.error(err); } } mounted() { this.initAMap(); } } \u0026lt;/script\u0026gt; 给地图添加marker const win: any = window const marker = new win.AMap.Marker({ position: new win.AMap.LngLat(113.171688,23.433279), //marker的坐标 }) 在marker上方添加文本:\nmarker.setLabel({ //label默认蓝框白底左上角显示l  offset: new win.AMap.Pixel(0, -3), //设置文本标注偏移量  content:\u0026#34;商业街\u0026#34;, //设置文本标注内容  direction: \u0026#39;top\u0026#39; //设置文本标注方位 }); 修改样式： 此时css标签中不能打 scoped ，否则无法生效，这个问题关乎css的作用域\n.amap-marker-label{ padding: 5px; border-radius: 3px; border-color: #54B7E7; border-width: 0px; color:#54B7E7; } 最后调用add方法添加：\nthis.map.add(marker) ","date":"2020-07-30T14:53:09Z","permalink":"https://magren.cn/%E5%85%B3%E4%BA%8Ehg%E5%9C%B0%E5%9B%BE/","title":"关于HG地图"},{"content":"过完这个暑假自己就是大三的学生了。\n曾经大一的时候觉得大三离自己挺遥远，实习工作远在天边，但是现在全都近在眼前。\n自己的设备更新了一批，要学习的知识换了又换，星空的换届，师兄师姐的毕业……很多事情都变了，唯一不变的是我依然那么菜，一如既往。\n过完这个暑假自己就是大三的学生了。 曾经大一的时候觉得大三离自己挺遥远，实习工作远在天边，但是现在全都近在眼前。 自己的设备更新了一批，要学习的知识换了又换，星空的换届，师兄师姐的毕业……很多事情都变了，唯一不变的是我依然那么菜，一如既往。\n大一 自己说出来可能都不信。 大一的压力比我大二的时候还大，可能是因为那时候都在想着怎么生存吧。 怎么在星空生存。\n刚开学组织招新的时候避开团委，避开校会，然后给星空一个挺有气质的师姐骗了进来。 虽然进来后我就一直没有再见到过这个师姐。 但是既来之则安之，就当学习点东西。 原本是这么打算的，直到经历了两次考核，才意识到好像不努力是会给淘汰掉。\n似懂非懂的看完了师兄发来的资料， 写着乱七八糟不带注释的代码， 莫名其妙的完成了要我们实现的功能， 熬夜逃课来完成x训营中小组的idea。 也是初生牛犊不怕虎，经常缠着师兄师姐问七问八，虽然也经常遇到他们不回我然后我自己一个人折腾出来的情况，也曾经把师兄师姐问的烦躁过。。。 依稀记得是给臭骂了一顿。\n大一是最投入的时候，没有什么好迷茫的，学就完事了。 也没什么特别的理由，就是不想输。\n \n大二 以为自己一jio直接成CTO了，没想到还是给打回原形，做回了一个副总监。 这个职位如果真给我做也是我捡漏来的，现在这样反而松了一口气。 给pass了还是很不爽，但是也的确是自己欠缺很多。\n招新的时候也知道了星空一个传统， 老一辈的会在招新的时候回来装萌新来玩玩。 在我跟一个人游说半个小时他告诉我是自己人的时候，我决定把这个传统发扬下去。（还我名片！）\n面试也是一个机会，老一辈的真的不放过，全是内鬼。 我的CTO不由分说进来拿了张我们的问卷就开始作答了， 最后一题是你认为程序员都是怎样的一群人（具体题目我忘了，但是大致的意思是这样吧），新生都是正儿八经的回答，\n “钻研在技术领域” “认真学习” “很严谨”\n 但是只有他的是画了个画，画了几个在一块小人，然后上面画了几个星星，左上角画太阳右上角画月亮，两个还用双箭头连在了一块，下面有电脑，写了个coding。 我们看到那简笔画的时候都想笑，毕竟知道他是来捣乱的，那自然也要顺一下他的意思，就刁难他：“你在我们的题目下画了一幅画，我们可以认为你对这次面试的心态是不端正的对吗，或者你给我们解释下你这副画是什么意思。”\n 啊，就是我觉得程序员就是，跟好朋友一起，在同一片星空下，从白天到黑夜都一起努力敲代码学习。\n 这也成了我心中最憧憬的答案。 看着他日渐攀升的发际线我多了一丝敬意。他临走去北京新浪实习的时候碰巧我在买奶茶，送了他上车后他说下次回来请我吃饭，虽然我现在都还没等到。\n一个副总监的开始无非就是重复上一届副总监的开始， 给新生讲讲课，内容所差无几，甚至连考核都是一摸一样的。 也曾一腔热血想做点产品出来，但是想法都给驳回， 老师想着做单一功能，产品简洁的项目，就差没直接告诉我“小程序”这三个字了。 打不过就加入！ 遂开始学习前端并决定往前端的方向走。\n疫情直接让我一个学期呆在了家里， 抛弃了在学校的社交，不用担心是否能抢到饭，换来的是我在家更安逸的玩电脑和玩手机。 整一个就是20岁的少年胡适。 不过也是有好处的， 在开会还有给大一的教东西的时候，我看不到下面的人了，省去我把他们想象成大头菜的想象力。\n在每次开会的时候胖师姐总会出现，然后也总会站出来发言，给我们一些建议还有灌几壶鸡汤， 甚至已经自封成为我们技术研发中心的程序员鼓励师。 虽然我觉得听她的鼓励不如自强，但是有这么一个职位总聊胜于无。 我想星空对她来说是一个十分重要的存在吧。 借了她的算法导论到现在还放在办公室里头，也不知道还有没有机会给回她了。\n \n最后 待开学了就差不多要换届了吧，大一新生的活力让我这个大二的感觉自己是真的老了。 初中的时候以为考个好的高中就安稳了， 高中的时候以为上了大学就安稳了， 上了大学发现还有很多事情要去担忧， 总是不能停下脚步，也不知道下一步该踏哪个方向， 大二的最后，带着遗憾还有不舍继续前往下一站。\n","date":"2020-07-15T16:11:42Z","permalink":"https://magren.cn/%E5%9C%A8%E5%A4%A7%E5%AD%A6%E9%87%8C%E8%BF%9E%E6%BB%9A%E5%B8%A6%E7%88%AC%E7%9A%84%E4%B8%A4%E5%B9%B4/","title":"在大学里连滚带爬的两年"},{"content":"终于度过了紧张刺激的期末以及三个大作业两个大作业的答辩。\n最没有把握的科目居然是这个学期唯一的开卷考——hadoop，考的东西我翻书也翻不到，虽然操作系统也挺难的，但好歹别人是46开（平时分占比6，期末考试占比4）。\n其实主要的还是自己没怎么听，嘿嘿。\n零 这个学期我们有一门课是软件工程，幸运的是这门课没有期末考，不幸的是这个老师要我们写6000字的论文（6000字啊！）。 论文是从几个题目里面挑一个来写，基于好写容易理解同时谷歌/百度后有很多样板以方便我们copy的原则，我们小组选了学生学籍管理系统。 老师：“这次作业不查重，你们也不用把这个项目实现，只要模仿我给你们的样板把他写出来就好了” 前面6000字给我带来的冲击小了一半，虽然我文笔挺差，但是我复制粘贴起来真的不含糊。\n就这样我殚精竭虑地想着方法来混过这一次作业。 但是人有时候偷着懒，却又对别人的努力感到惶恐不安。 快到截止的时间我准备动手的时候，舍友突然在我们的舍友群里信息轰炸。 “xx真的把他们选的项目做出来了喂！” “什么东西？” “就是软件工程那个” 我也可以赞叹一句，然后就接着躺在床上刷手机，安稳混过这个期末。退一步海阔天空，但是忍一时越想越气。\n Somebody has to win, so why not be me?\n 我也得动手搞一个，前一阵子看了下vue，就当作拿来练练手了，这样就算失败也是有理由的了吧（自我安慰\n一、面向搜索引擎编程 说实话，因为这是第一次是实际上手，所以我早就想到肯定会踩到很多坑，但是我没想到一上来就给了我一个下马威。\n页面最上方存在白条问题 我开始写好了一个登陆注册的页面，但是无论我怎么更改css属性，最上方都存在一个白条，特地去谷歌搜索也是搜索出来一堆css的属性设置（虽然的确是样式的问题）。 最后钻牛角尖的我不停的翻找答案，最后在一个与这个问题毫不相干的文章上找出了解决的办法，同时真的给我科普了一波。\n首先index.html是项目的运行入口，在body体中只有一个div标签，其id为app，这个id将会连接到src/main.js内容， 然后main.js中又初始化vue的实例，也就是说通过main.js我们关联到App.vue组件。 接着在App.vue组件中，标签将会把路由相关内容渲染在这个div里，而路由的内容，则在index.js里。 在index.js里面，将我们写好的组件发布成路由。\n以上就是vue项目的运行加载过程，接着在网页上F12查看我的页面属性，发现是一个body设置了外边距8px，但是我写的登陆页面（组件）已经设置了背景铺满，而我们的组件是渲染到App.vue里的div，那么是不是我给div添加一个外边距为0的样式就可以解决？ 于是我在App.vue里面的div添加样式，让它的外边距为0，成功显示了我想要的结果。\n\u0026lt;template\u0026gt; \u0026lt;div id=\u0026quot;app\u0026quot; style=\u0026quot;margin: 0px;\u0026quot;\u0026gt; \u0026lt;router-view/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 因为最终所有的路由都会给加载到index.html里面，所以在html里的body添加一个外边距为0的样式也可以解决这个问题。\n 登陆界面 \n传参问题 首先说说我了解到的页面之间跳转传参的方式，一个是query，另一个是params\nquery传参以及接收 传参\nthis.$router.push({ path: '/Home', query: { id: res.objectId, } }) 接收\nthis.$route.query.id params传参以及接收 传参\nthis.$router.push({ name: 'Home', params: { id: res.objectId, } }) 接收\nthis.$route.params.id params传参的时候，push里的路径只能是填写name，params只能通过name来引入路由，如果写成了path则接收参数页面会显示undefind 另外要说的是，query相当于get请求，可以在跳转后的地址栏上看到参数，而params则相当于post，地址栏看不到传递的参数。\n好的那么跳转页面传参的方法我已经知道了，但是当我满怀期待的传了个对象的时候，接收到的数据却是：’[object object]’。 啊？？？遂检查了下他的类型，就是一个String…… 我对象呢？我对象呢！\n也是通过谷歌后解决，在传递之前先把对象转换成json字符串：\nJSON.stringify(res); 然后再接收的页面将json字符串转换回对象\nJSON.parse(this.$route.query.res) 关于v-bind和v-model 这两个东西在我赶这个项目的时候经常出现，也让我经常把这两个搞混，毕竟都是绑定数据。\nv-bind v-bind只能实现一个单向的绑定，即从model到view，无法实现双向绑定。 可用来绑定文本：\n\u0026lt;p\u0026gt;{{message}}\u0026lt;/p\u0026gt; \u0026lt;p v-bind=\u0026quot;message\u0026quot;\u0026gt;\u0026lt;/p\u0026gt; 也可用来绑定属性：\n\u0026lt;img v-bind:src=\u0026quot;res\u0026quot;\u0026gt; v-model v-model可以实现双向的绑定，但是他有个限制就是只能用于表单当中。 绑定text：\n\u0026lt;input type=\u0026quot;text\u0026quot; v-model=\u0026quot;val\u0026quot; /\u0026gt; 绑定radio：\n\u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;one\u0026quot; v-model=\u0026quot;radioResult\u0026quot; /\u0026gt; \u0026lt;input type=\u0026quot;radio\u0026quot; value=\u0026quot;two\u0026quot; v-model=\u0026quot;radioResult\u0026quot; /\u0026gt; 在这里radioResult的值，随着单选框的点击，会成one或two\n点击图片更换图片 这个功能有点取巧，一开始我还傻傻的转不过脑子来，后面看了别人实现才觉得妙啊…… 首先我们写一个图片的标签，以及一个文件选择的标签，同时给图片添加一个点击监听事件：\n\u0026lt;img v-bind:src=\u0026quot;icon\u0026quot; @click=\u0026quot;selectIcon\u0026quot; class=\u0026quot;icon\u0026quot;\u0026gt; 接着我们要隐藏我们的文件选择的标签，即设置display样式，同时用ref属性注册一个引用信息，方便在方法中调用，还有设置change事件。如果需要多选的话可以设置multiple属性：\n\u0026lt;input type=\u0026quot;file\u0026quot; ref=\u0026quot;btn_file\u0026quot; @change=\u0026quot;getFile\u0026quot; style=\u0026quot;display:none\u0026quot;\u0026gt; 这个时候是只能看见我们的图片但是看不到我们的文件选择按钮的，在图片点击后触发的方法中，我们通过$refs引用我们的文件选择按钮，同时触发它：\nselectIcon: function(){ let selectFile = this.$refs.btn_file; selectFile.click(); } 这个时候我们的文件选择就会触发，选择我们的图片后会触发其change事件：\ngetFile: function(){ this.file = event.target.files[0]; //判断选中文件的格式 if(this.file.type!=\u0026quot;image/png\u0026quot;\u0026amp;\u0026amp;this.file.type!=\u0026quot;image/bmp\u0026quot;\u0026amp;\u0026amp;this.file.type!=\u0026quot;image/jpeg\u0026quot;\u0026amp;\u0026amp;this.file.type!=\u0026quot;image/jpg\u0026quot;){ window.alert(\u0026quot;仅支持png、bmp、jpeg、jpg文件\u0026quot;); return; } //该方法返回一个DOMString包含了一个对象URL，该URL指定文件的内容。 this.icon = window.URL.createObjectURL(this.file); } 限制文件上传的类型其实也可以在标签中添加accept属性，即：accept=“image/gif, image/jpeg”。 假如不限制图像格式的话也可以写成： accept=\u0026ldquo;image/*\u0026quot; 但是accept这个属性并不建议使用，因为一方面在部分浏览器上会响应很慢或者不支持，并且有时候还是可以选择到指定格式之外的文件。 应通过js验证或者后台服务器判断。\n组件中引用别的组件同时传递数据 在做项目的首页的时候我需要通过点击旁边的菜单栏不同的栏目，在右边的界面中呈现不同的界面，于是我就想到了通过点击然后切换右边不同的子组件。 写好一个组件后，我首先得把它引用到当前的组件中： import selectClass from \u0026lsquo;…/components/selectClass’ 接着在components声明：\ncomponents: { selectClass }, 在data中声明：\ndata(){ return{ ··· selectClass:'selectClass', ··· } } 在需要的地方中用is引入就好了：\n\u0026lt;div :is=\u0026quot;contentView\u0026quot; \u0026gt;\u0026lt;/div\u0026gt; 接下来就是要从父组件中传参到子组件，有几种传递方式，我这里选用的是props 通过v-bind将动态props绑定到父组件的数据，父组件的数据发生改变，子组件也会随之改变：\n\u0026lt;div :is=\u0026quot;contentView\u0026quot; v-bind:objectId=\u0026quot;objectId\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 接着在子组件中，用props获取：\n\u0026lt;script\u0026gt; export default{ props:['objectId'] data(){ return{ } } }, ······ \u0026lt;/srcipt\u0026gt; 接着我们就可以在子组件中通过this.objectId来调用父组件中传来的参数了。\n二、最后 因为这是三天赶出来的东西（要交上去了），所以我对自己第一次用vue写的这个项目还是比较满意的（嘿嘿），但是就目前来看的话应该还有很多可以优化的东西，仔细想想应该趁热打铁，深一点了解后再去学别的东西吧，还有自己在css样式上不是非常熟练，果然看看是不行的，亲自写一遍总是可以踩到非常多的坑，不能自满。\n这次的期末作业事件应该可以说是一个混子被迫运营吧。\n","date":"2020-07-10T13:28:29Z","permalink":"https://magren.cn/%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/","title":"用vue实现的期末作业"},{"content":"Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\nPromise也有一些缺点：\n 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。  promise的特点  对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise的对象状态改变，要么是成功，要么就是失败，只要发生这两种情况，状态就会凝固，称为resolvd（已定型）。改变发生后，再添加回调函数，也是会得到这个结果。  用法 创造Promise实例 Promise对象是一个构造函数，用来生成Promise实例。\nconst promise = new Promise(function(resolve, reject) { if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } });  resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；\n  reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n then方法 接着用then方法指定resolved状态和rejected状态的回调函数：\npromise.then(function(value) { // success }, function(error) { // failure }); 第一个函数是状态对象变为rejected的调用，第二个是resolved的调用，第二个函数是可选的。\nthen方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。\npromise.then(function(value) { }.then(function (comments) { console.log(\u0026#34;resolved: \u0026#34;, comments); }, function (err){ console.log(\u0026#34;rejected: \u0026#34;, err); }); catch方法 用于指定发生错误时的回调函数。\npromise.then(function(value) { // success }, function(error) { // failure }).catch(function(error) { // 处理发生的错误  console.log(\u0026#39;发生错误！\u0026#39;, error); }); 如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误。另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。\n 跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。\n finally方法 用于指定不管 Promise 对象最后状态如何，都会执行的操作。\npromise.then(function(value) { // success }, function(error) { // failure }).catch(function(error) { // 处理发生的错误  console.log(\u0026#39;发生错误！\u0026#39;, error); }).finally(function(){ alert(\u0026#34;finish\u0026#34;); }); finally方法的回调函数不接受任何参数,意味着无法知道最终的状态是怎样的。\nJquery、Ajax、Promise示例 之前学了Jquery和ajax，就顺手在网上随便找了个api测试下：\nconst apiUrl = \u0026#34;https://suggest.taobao.com/sug?code=utf-8\u0026amp;q=电脑\u0026amp;callback=cb\u0026#34;; $(\u0026#34;#bt\u0026#34;).click(apiUrl,function(event){ const promise = new Promise(function(resolve,reject){ $.ajax({ url: event.data, type:\u0026#34;get\u0026#34;, dataType:\u0026#34;jsonp\u0026#34;, headers: { Accept: \u0026#34;application/json; charset=utf-8\u0026#34;, }, success: function(data) { resolve(data); }, error: function(XMLHttpRequest, textStatus, errorThrown) { reject(XMLHttpRequest,textStatus,errorThrown) }, }) }) promise.then(function(data){ console.log(data); let x = data.result; for(let i = 0 ; i\u0026lt;data.result.length;i++){ console.log(x[i][0]); } },function(XMLHttpRequest, textStatus, errorThrown){ alert(XMLHttpRequest); alert(textStatus); alert(errorThrown); }).catch(function(error){ console.log(error); }).finally(function(){ alert(\u0026#34;finish\u0026#34;); }); }); 结果： 遇到的问题 其实在Promise基础的学习上没有什么太大的问题，但是在ajax请求的时候遇上了一个跨域的问题，就是：\n Access to XMLHttpRequest at ‘这里是api’ from origin ‘null’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.\n 这是什么啊…… 简单的了解了下，先说说跨域的概念吧\n 每个网站只能读取同一来源的数据，这里的同一来源指的是主机名(域名)、协议(http/https)和端口号的组合。在没明确授权的情况下，不能读写对方的资源，它是浏览器最核心也最基本的安全功能；只要有一个不一样就跨域。\n 而Ajax的XMLHttpRequest受到了同源限制，只能访问同源下的数据，所以就报这个错。 所以怎么还没说怎么解决嗷？？？\n在搜到的文章里面大部分都是后端配合设置一个请求权限，但是我这是野生的api。。。我还腆着脸去要求别人做这做那哦？  \n直到我找到个方法，jsonp\njsonp:\n 通过script标签引入某些数据，是同步模式的，用script标签做跨域的时候，不建议将数据提前加载，需要按需加载； 当需要数据的时候创建一个script标签，将需要的数据放在src中，通过onload去监听是否请求过来，请求完毕就调用传回来的数据（异步加载）； jsonp不能用post请求，只能是get请求；  所以为啥这个类型就可以跨域了？？？\n 带src属性script、img、iframe、link等标签是不需要遵守同源策略的，但是通过src加载的资源，浏览器限制了javascript的权限, 能读不能写\n 综上所述：把dataType类型从json改成jsonp就可以了。\n","date":"2020-05-27T21:29:47Z","permalink":"https://magren.cn/es6%E4%B8%AD%E7%9A%84promise/","title":"es6中的promise"},{"content":"记录下自己最近看的知识点。\nHTML DOM (文档对象模型) 概述： 当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。\n查找HTML元素 通常，通过 JavaScript可以操作需要操作 HTML 元素。\n为了做到这件事情，必须首先找到该元素。有三种方法来做这件事：\n 通过 id 找到 HTML 元素：var x=document.getElementById(“intro”); 通过标签名找到 HTML 元素：var y=document.getElementsByTagName(“p”); 通过类名找到 HTML 元素：var x=document.getElementsByClassName(“intro”);  改变HTML内容 使用 innerHTML 属性。\n\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;p1\u0026#34;\u0026gt;Hello World!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#34;p1\u0026#34;).innerHTML=\u0026#34;新文本!\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 改变HTML样式 使用style\n\u0026lt;body\u0026gt; \u0026lt;p id=\u0026#34;p1\u0026#34;\u0026gt;Hello World!\u0026lt;/p\u0026gt; \u0026lt;p id=\u0026#34;p2\u0026#34;\u0026gt;Hello World!\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#34;p2\u0026#34;).style.color=\u0026#34;blue\u0026#34;; document.getElementById(\u0026#34;p2\u0026#34;).style.fontFamily=\u0026#34;Arial\u0026#34;; document.getElementById(\u0026#34;p2\u0026#34;).style.fontSize=\u0026#34;larger\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 使用事件 \u0026lt;body\u0026gt; \u0026lt;h1 id=\u0026#34;id1\u0026#34;\u0026gt;我的标题 1\u0026lt;/h1\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;document.getElementById(\u0026#39;id1\u0026#39;).style.color=\u0026#39;red\u0026#39;\u0026#34;\u0026gt; 按钮\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt; JS中定义函数绑定事件 var funcc = function () { alert(\u0026#34;hello world\u0026#34;) } var aa = document.getElementById(\u0026#39;vv\u0026#39;) aa.onclick = funcc 利用addEventListener document.getElementById(\u0026#39;vv\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,funcc); document.getElementById(\u0026#39;vv\u0026#39;).addEventListener(\u0026#39;click\u0026#39;,function () { alert(\u0026#39;hahah\u0026#39;) }) onload 和 onunload 事件  onload 和 onunload 事件会在用户进入或离开页面时被触发。 onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。 onload 和 onunload 事件可用于处理 cookie。  \u0026lt;body onload=\u0026#34;checkCookies()\u0026#34;\u0026gt; \u0026lt;script\u0026gt; function checkCookies(){ if (navigator.cookieEnabled==true){ alert(\u0026#34;Cookies 可用\u0026#34;) } else{ alert(\u0026#34;Cookies 不可用\u0026#34;) } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; onchange 事件 onchange 事件常结合对输入字段的验证来使用。\n\u0026lt;!-- 当输入框内容改变，焦点离开输入框的时候会调用函数 --\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;fname\u0026#34; onchange=\u0026#34;upperCase()\u0026#34;\u0026gt; onmouseover ，onmouseout和onmousedown，onmouseup 事件  onmouseover：当鼠标移到html元素上方的时候触发事件 onmouseout：当鼠标从html元素上方移开的时候触发事件 onmousedown：当鼠标点下元素的时候，触发事件 onmouseup：当鼠标释放按钮时，触发事件。  HTMLCollection 对象 概述：getElementsByTagName() 方法返回 HTMLCollection 对象。HTMLCollection 对象类似包含 HTML 元素的一个数组。集合中的元素可以通过索引(以 0 为起始位置)来访问。\nvar x = document.getElementsByTagName(\u0026#34;p\u0026#34;); y = x[1]; //访问第二个p元素 NodeList 对象 概述：NodeList 对象是一个从文档中获取的节点列表 (集合) 。\n通过querrySelectorAll属性来获取对象\nvar myNodeList = document.querySelectorAll(\u0026#34;p\u0026#34;); 同样通过索引的方法来访问元素。\nNodeList和HTMLCollection两者的区别  HTMLCollection 元素可以通过 name，id 或索引来获取。 NodeList 只能通过索引来获取。 只有 NodeList 对象有包含属性节点和文本节点。  浏览器对象模型 (BOM) 该对象表示浏览器窗口，全局变量是 window 对象的属性。全局函数是 window 对象的方法（包括document）。\nWindow 尺寸  window.innerHeight - 浏览器窗口的内部高度(包括滚动条) window.innerWidth - 浏览器窗口的内部宽度(包括滚动条)  Window Screen  screen.availWidth - 可用的屏幕宽度 screen.availHeight - 可用的屏幕高度  Window Location  location.hostname 返回 web 主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回 web 主机的端口 （80 或 443） location.protocol 返回所使用的 web 协议（http: 或 https:） location.href 返回当前页面的URL location.assign(url) 加载 URL 指定的新的 HTML 文档。 就相当于一个链接，跳转到指定的url，当前页面会转为新页面内容，可以点击后退返回上一个页面。 location.replace(url) 通过加载 URL 指定的文档来替换当前文档 ，这个方法是替换当前窗口页面，前后两个页面共用一个窗口，所以是没有后退返回上一页的。  Window History  history.back() - 与在浏览器点击后退按钮相同 history.forward() - 与在浏览器中点击向前按钮相同  在进行前进后退功能上，也可以通过history.go()方法来实现\nhistory.go(1); // go() 里面的参数表示跳转页面的个数 例如 history.go(1) 表示前进一个页面 history.go(-1); // go() 里面的参数表示跳转页面的个数 例如 history.go(-1) 表示后退一个页面 history.go(0); // go() 里面的参数为0,表示刷新页面 弹窗 警告框 alert()\nalert(\u0026#34;警告框！\u0026#34;); 确认框 confirm()\nvar r=confirm(\u0026#34;按下按钮\u0026#34;); if (r==true) { x=\u0026#34;你按下了\\\u0026#34;确定\\\u0026#34;按钮!\u0026#34;; } else { x=\u0026#34;你按下了\\\u0026#34;取消\\\u0026#34;按钮!\u0026#34;; } 提示框 prompt() - 当提示框出现后，用户需要输入某个值，然后点击确认或取消按钮才能继续操纵。\nvar person=prompt(\u0026#34;请输入\u0026#34;); if (person!=null \u0026amp;\u0026amp; person!=\u0026#34;\u0026#34;){ document.getElementById(\u0026#34;demo\u0026#34;).innerHTML=person; } JavaScript 计时事件  setInterval() - 间隔指定的毫秒数不停地执行指定的代码。括弧内两个参数，第一个参数是函数，第二个参数是毫秒数。 setTimeout() - 在指定的毫秒数后执行指定代码。第一个参数是函数，第二个参数是毫秒数。  关于停止计时的方法：clearInterval() 和 clearTimeout()\nvar myVar=setInterval(function(){myTimer()},1000); function myTimer(){ alert(\u0026#34;Hello\u0026#34;); } function myStopFunction(){ clearInterval(myVar); } var myVar; function myFunction() { myVar=setTimeout(function(){alert(\u0026#34;Hello\u0026#34;)},3000); } function myStopFunction() { clearTimeout(myVar); } Cookie 概述：Cookie 是一些数据, 存储于你电脑上的文本文件中。以键值对的形式储存。\n创建Cookie document.cookie=\u0026#34;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT\u0026#34;; //expries是该cookie的过期时间，默认情况下，cookie 在浏览器关闭时删除 document.cookie=\u0026#34;username=John Doe; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/\u0026#34;; //path 参数告诉浏览器 cookie 的路径。默认情况下，cookie 属于当前页面。 读取 Cookie var x = document.cookie; 修改 Cookie document.cookie=\u0026#34;username=John Smith; expires=Thu, 18 Dec 2043 12:00:00 GMT; path=/\u0026#34;; //类似创建，直接覆盖 Cookie的获取 设置了新的 cookie，旧的 cookie 不会被覆盖。 新 cookie 将添加到 document.cookie 中，所以如果重新读取document.cookie，将获得如下所示的数据： cookie1=value; cookie2=value;\nfunction getCookie(cname) { var name = cname + \u0026#34;=\u0026#34;; var ca = document.cookie.split(\u0026#39;;\u0026#39;); for(var i=0; i\u0026lt;ca.length; i++) { var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); } return \u0026#34;\u0026#34;; } ","date":"2020-05-09T17:52:32Z","permalink":"https://magren.cn/html%E7%9A%84dom%E5%92%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84bom/","title":"HTML的DOM和浏览器的BOM"},{"content":"其实在大一就有学习前端的想法，也就多多少少了解了一点html和css，但是那时候身在安卓方向，就还是以安卓为主，也没有坚持下去。\n工程师嘛，无论是什么工程师，局限于一个领域上所学到的东西肯定是有限的，it界那么大，总得看看别的地方。\n如果硬要说我想成为什么工程师，我希望我能成为一个全栈工程师吧（有能力的话\n杂七杂八的要点 这里主要是记了一些我需要重要理解或者容易忘记的知识点。没有一个固定的逻辑顺序。\n定位問題 最常用的两个：absolute 和 relative\n absolut: 脱离原来的位置定位。对最近有定位的父级进行定位，假如没有则相对文档进行定位。 relative: 保留原来的位置进行定位。相对自己原来的位置定位。  z-index: 改变元素的层面，代表该元素的Z轴，默认是0。\n当元素使用float属性定义元素往哪个方向浮动的时候，需要后面的元素不再继续浮动在后面的时候，可用：\n.nav::after{ content:\u0026#34;\u0026#34;; display:block; clear:both; } 字体  当字体超出长度，为了页面整洁美观，多余的字体用……表示：  .product-buyer-name { overflow: hidden; /*隐藏超出单元格的部分。*/ text-overflow: ellipsis; /*文字超出部分用省略号*/ white-space: nowrap; /*保证无论单元格（TD）中文本内容有多少，都不会自动换行，此时多余的内容会在水平方向撑破单元格*/ }   网页上的一些小图标 我一直以为，在网页上的一些小图标是通过插入img来显示的，但是再深入一点了解到，类似淘宝网上的tab栏的小图标是通过一个自定义显示出来的。 这里我规划到了字体类是因为当我们需要显示部分字体，但是电脑上没有该字体的时候是无法显示的，这里我们就要用一样的方法，将这个字体的资源加载进去，达到一个显示他人电脑字体不存在也依然可以看到该字体的效果。\n 淘宝网tab栏 \n  那么这种字体资源还有图标资源该怎么来呢，当然是， Google或者百度啦 在阿里巴巴矢量图标库上有挺多资源，我们在里面挑选我们需要的资源并且加入购物车后下载源码\n 阿里巴巴矢量图标库   加入购物车 \n下载到的源码里有资源的文件以及他一个css的demo，在使用上我们先拷贝资源文件后。\n 拷贝项目下面生成的font-face  @font-face {font-family: \u0026#39;iconfont\u0026#39;; src: url(\u0026#39;iconfont.eot\u0026#39;); src: url(\u0026#39;iconfont.eot?#iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), url(\u0026#39;iconfont.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), url(\u0026#39;iconfont.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), url(\u0026#39;iconfont.svg#iconfont\u0026#39;) format(\u0026#39;svg\u0026#39;); }  定义使用的iconfont使用样式  .iconfont{ font-family:\u0026#34;iconfont\u0026#34; !important; font-size:16px;font-style:normal; -webkit-font-smoothing: antialiased; -webkit-text-stroke-width: 0.2px; -moz-osx-font-smoothing: grayscale;}  挑选相应图标并获取字体编码，应用于页面  \u0026lt;i class=\u0026#34;iconfont\u0026#34;\u0026gt;\u0026amp;#x33;\u0026lt;/i\u0026gt; JavaScript 中 var,let,const的区别 const:声明一个只读的常量，一旦声明，常量的值就不能改变。 let:声明的变量只在 let 命令所在的代码块内有效。\n变量提升 概述：变量可在声明之前使用。\n var: 允许 let：不允许 const：不允许  console.log(a);//正常运行，控制台输出 undefined var a = 1; console.log(b);//报错，Uncaught ReferenceError: b is not defined let b = 1; console.log(c);//报错，Uncaught ReferenceError: c is not defined const c = 1; 主要是为了减少运行时错误，防止变量声明前就使用这个变量，从而导致意料之外的行为。\n暂时性死区 概述：如果在代码块中存在 let 或 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n var: 存在 let：不存在 const：不存在  例子：\nvar num = 123; if (true) { num = \u0026#39;abc\u0026#39;;//报错 \tlet num; } 解释：存在全局变量 num，但是块级作用域内 let 又声明了一个 num变量，导致后者被绑定在这个块级作用域中，所以在 let 声明变量前，对 num 赋值就报错了。\n重复声明 概述：指在相同作用域内，重复声明同一个变量。\n var: 允许 let：不允许 const：不允许  var 允许重复定义所带来的后果：\nvar i = 10; for(var i = 0;i \u0026lt; 5;i++){ console.log(i); } console.log(i);// 输出 5 var命令没有块级作用域,for循环里的i会替代外层的i。\n初始值  var: 不需要 let：不需要 const：需要  作用域  var: 除块级 let：块级 const：块级  块级作用域：\nfunction f1() { let n = 5; if (true) { let n = 10; console.log(n); // 10 内层的n  } console.log(n); // 5 当前层的n } 这种的好处是，可以用于测试一些想法，不用担心变量重名，也不用担心外界干扰，var的作用域会有可能导致上面重复声明例子中的情况\n","date":"2020-05-02T16:34:16Z","permalink":"https://magren.cn/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%87%8C%E4%B8%80%E4%BA%9B%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/","title":"前端基础里一些杂七杂八的知识点"},{"content":"这两天在网上想着找Android系统学习的路线，然后发现了阿里云上的阿里巴巴Android开发手册，虽然网上已经有免费下载的地方了，不过凭着不能白嫖的感觉，我还是花钱支持了下，其实就卖一块钱，而且还有一份考试证书的资格，总的来说还是很舒服的。\n这两天在网上想着找Android系统学习的路线，然后发现了阿里云上的阿里巴巴Android开发手册，虽然网上已经有免费下载的地方了，不过凭着不能白嫖的感觉，我还是花钱支持了下，其实就卖一块钱，而且还有一份考试证书的资格，总的来说还是很舒服的。\n网址在下面：\n 阿里巴巴Android开发手册\n 估摸是我接触的太少的缘故，在一开始的第一条我就懵掉了\n  【强制】Activity 间的数据通信，对于数据量比较大的，避免使用 Intent + Parcelable 的方式，可以考虑 EventBus 等替代方案，以免造成 TransactionTooLargeException。   这个EventBus……是啥？？？\nEventBus概述 EventBus是一个Android事件发布/订阅框架，通过解耦发布者和订阅者简化Android事件传递，这里的事件可以理解为消息。事件传递既可以用于Android四大组件间通讯，也可以用于异步线程和主线程间通讯等。 传统的事件传递方式包括：Handler、BroadcastReceiver、Interface回调，相比之下EventBus的有点是代码简洁，使用简单，并将事件发布和 订阅充分解耦。\n在这里面，又有三个对象：\n 事件Event：就是消息，分为一般事件和Sticky（黏性）事件，Sticky事件的特殊在于，当事件发布后，再有订阅者订阅该类型事件，依然能收到该类型 事件的最近的一个Sticky事件 订阅者Subscriber：订阅事件的对象，当发布者发布事件猴，EventBus会执行订阅者的事件响应函数。订阅者通过register接口订阅某个事件类型，unregister接口退订 发布者：发布事件的对象，通过post接口发布事件，黏性事件通过postSticky  Github地址：EventBus\n使用 道理我都懂，但是我得知道它是怎么用的，不然日后复制起来粘贴在哪都不知道，于是我在网上找到了它的使用方法。\n一般事件 自定义一个事件类 public class Event { String message; public Event(String message){ this.message = message; } public String getMessage() { return message; } } 在需要接收消息的页面注册 EventBus.getDefault().register(this); 接收消息的方法 @Subscribe(threadMode = ThreadMode.MAIN) public void getEvent(Event event) { msg = event.getMessage(); tv.setText(msg); } 发送事件 @OnClick(R.id.bt_return) public void renturnActivity(){ //发送事件  EventBus.getDefault().post(new Event(\u0026#34;Magren\u0026#34;)); finish(); } 在注册的页面销毁的时候反注册 @Override protected void onDestroy() { super.onDestroy(); //反注册  EventBus.getDefault().unregister(this); } 通过上面的方法，实现了在MainActivity中注册EventBus事件，然后写好响应事件的方法，当跳转到另一个Activity，点击按钮向MainActivity发送Event事件，同时我们回到MainActivity的时候发现我们的事件已经接收到并且呈现了出来。\nMainActivit: SendMainActivity:  \n返回MainActivity：  \n这是一般事件的使用方法，但是我想的传递数据是在当前Activity向下一个Activity传递数据并且在下一个Activity使用，但是我用上面的方法去实现的时候发现并不能派上用场，后面我才清楚了这里得用上我们的黏性事件。\nSticky事件 自定义一个事件类 public class Event { String message; public Event(String message){ this.message = message; } public String getMessage() { return message; } } 在需要接收消息的页面注册 EventBus.getDefault().register(this); 接收消息的方法 此时多了sticky = true\n@Subscribe(sticky = true,threadMode = ThreadMode.MAIN) public void getEvent(Event event) { msg = event.getMessage(); tv.setText(msg); } 发送事件 先发送消息后进行Activity的跳转，注意这里是postSticky，发送黏性事件\n@OnClick(R.id.bt_return) public void renturnActivity(){ //发送事件  EventBus.getDefault().postSticky(new Event(\u0026#34;Magren\u0026#34;)); Intent intent = new Intent(this,MainActivity.class); startActivity(intent); } 在注册的页面销毁的时候反注册 @Override protected void onDestroy() { super.onDestroy(); //反注册  EventBus.getDefault().unregister(this); } 这时候我们就可以实现直接向下一个Activity发送事件并且在里面获取并使用了。\n1.SendActivity  \n2.MainActivity  \nEventBus处理事件的线程 上面我们的注解@Subscribe(threadMode = ThreadMode.MAIN)里面用了ThreadMode.MAIN这个模式，其实表示的是这个函数在主线程里面进行，EventBus给我们提供了总共有4中线程模式\n ThreadMode.MAIN：表示无论事件是在哪个线程发布出来的，该事件订阅方法onEvent都会在UI线程中执行，这个在Android中是非常有用的，因为在Android中只能在UI线程中更新UI，所有在此模式下的方法是不能执行耗时操作的。 ThreadMode.POSTING：表示事件在哪个线程中发布出来的，事件订阅函数onEvent就会在这个线程中运行，也就是说发布事件和接收事件在同一个线程。使用这个方法时，在onEvent方法中不能执行耗时操作，如果执行耗时操作容易导致事件分发延迟。 ThreadMode.BACKGROUND：表示如果事件在UI线程中发布出来的，那么订阅函数onEvent就会在子线程中运行，如果事件本来就是在子线程中发布出来的，那么订阅函数直接在该子线程中执行。 ThreadMode.AYSNC：使用这个模式的订阅函数，那么无论事件在哪个线程发布，都会创建新的子线程来执行订阅函数  注意点  注册一般写在onCreate或者onStart中，尽量不要写在onResume，可能出现多次注册，多次注册会出现报错以及APP闪退 取消注册一定写在onDestory,写在onStop可能会引发异常，同时检查或许会导致页面退出的情况，及时取消注册 注册前可以先判断是否已经注册  if (!EventBus.getDefault().isRegistered(this)) { EventBus.getDefault().register(this); }  未声明threadMode的时候默认线程模式是ThreadMode.POSTING  以上就是我从网上总结的部分EventBus的使用以及自己的实操，每次随便逛逛都可以发现我不懂的知识点，任重道远\n","date":"2020-04-16T15:43:52Z","permalink":"https://magren.cn/android%E7%9A%84eventbus%E4%BD%BF%E7%94%A8/","title":"Android的EventBus使用"},{"content":" 自定义 View 就是通过继承 View 或者 View 的子类，并在新的类里面实现相应的处理逻辑（重写相应的方法），以达到自己想要的效果。\n 分类  自定义ViewGroup：自定义ViewGroup一般是利用现有的组件根据特定的布局方式来组成新的组件，大多继承自ViewGroup或各种Layout，包含有子View。 自定义view: 在没有现成的View，需要自己实现的时候，就使用自定义View，一般继承自View，SurfaceView或其他的View，不包含子View。  构造函数 无论是我们继承系统View还是直接继承View，都需要对构造函数进行重写，构造函数有多个，至少要重写其中一个才行。\npublic class TestView extends View { /** * 在java代码里new的时候会用到 * @param context */ public TestView(Context context) { super(context); } /** * 在xml布局文件中使用时自动调用 * @param context */ public TestView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } /** * 不会自动调用，如果有默认style时，在第二个构造函数中调用 * @param context * @param attrs * @param defStyleAttr */ public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } /** * 只有在API版本\u0026gt;21时才会用到 * 不会自动调用，如果有默认style时，在第二个构造函数中调用 * @param context * @param attrs * @param defStyleAttr * @param defStyleRes */ @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP) public TestView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) { super(context, attrs, defStyleAttr, defStyleRes); } } 绘制过程  测量 布局 绘制 提供接口  测量阶段  View的父View通过调用View的measure()方法将父View对View尺寸要求传进来。 View的measure()方法进行一些前置和优化工作 调用onMeasure()方法，在方法中根据业务需求进行相应的逻辑处理。在自定义 ViewGroup 的 onMeasure() 方法中，ViewGroup 会递归调用子 View 的 measure() 方法，并通过 measure() 将 ViewGroup 对子 View 的尺寸要求 对自己的尺寸要求和自己的可用空间计算出自己对子 View 的尺寸要求）传入，对子 View 进行测量，并把测量结果临时保存，以便在布局阶段使用。ViewGroup 会根据子 View 的实际尺寸计算出自己的期望尺寸，并通过 setMeasuredDimension() 方法告知父 View（ViewGroup 的父 View） 自己的期望尺寸。 方法里调用**setMeasuredDimension()**方法告知父View自己的期望尺寸  onMeasure()计算View的期望尺寸的方法：\n 参考父 View 的对 View 的尺寸要求和实际业务需求计算出 View 的期望尺寸：  解析 widthMeasureSpec； 解析 heightMeasureSpec； 将「根据实际业务需求计算出 View 的尺寸」根据「父 View 的对 View 的尺寸要求」进行相应的修正得出 View 的期望尺寸（通过调用 resolveSize() 方法)   通过 setMeasuredDimension() 保存 View 的期望尺寸（实际上是通过 setMeasuredDimension() 告知父 View 自己的期望尺寸  onMeasure() ：\n@Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int widthsize MeasureSpec.getSize(widthMeasureSpec); //取出宽度的确切数值  int widthmode MeasureSpec.getMode(widthMeasureSpec); //取出宽度的测量模式  int heightsize MeasureSpec.getSize(heightMeasureSpec); //取出高度的确切数值  int heightmode MeasureSpec.getMode(heightMeasureSpec); //取出高度的测量模式 } widthMeasureSpec 和 heightMeasureSpec 这两个 int 类型的参数其实不是宽和高， 而是由宽、高和各自方向上对应的测量模式来合成的一个值\n布局阶段  父View通过调用View的Layout方法将View的实际尺寸传给View View在Layout方法中调用setFramne()方法保存 setFrame()方法中又会调用onSizeChanged()方法告知开发者View的尺寸修改了 View的Layout()方法调用View的onLayout()方法，它是一个空实现。但是在ViewGroup中，这里会调用子View的Layout()方法，将子View的实际尺寸传给他们，让子View保存实际尺寸。在自定义ViewGroup中需要重写该方法。  绘制阶段  draw() ，总调度方法，会调用绘制背景的方法，绘制主题的方法，绘制前景的方法和绘制子View的方法 onDraw() ，绘制View主体内容的方法 dispatchDraw()，绘制子View的方法，在自定义ViewGroup中会调用ViewGroup.drawChild()方法，这个方法会调用每个子View的View.draw() drawBackground()，绘制背景的方法，不可重写，只能通过xml布局文件或者setBackground()方法来设置背景。 onDrawForegound()，绘制View前景的方法，绘制主体内容之上的东西的时候在该方法中实现。  提供接口 写一些控制View或者监听View某些状态。\n","date":"2020-04-14T15:16:34Z","permalink":"https://magren.cn/android%E8%87%AA%E5%AE%9A%E4%B9%89view%E7%9A%84%E5%AE%9A%E4%B9%89/","title":"Android自定义view的定义"},{"content":"之前在学习Rxjava的时候发现仍有部分知识点自己遗漏了，不够严谨，在这里补充多一个知识点。那就是CompositeDisposable类。\n在用Rxjava配合Retorfit的时候，发送请求，拿到数据后我们要让数据显示在视图中的时候往往会刷新页面，但假如，我们发送请求出去的时候网络比较差，返回数据比较慢，然后我们又手快的关闭了当前这个Activity，那RxJava当拿到返回的数据的时候去刷新界面就会报空指针异常了。就是说，请求过程中，我们的UI层Destroy的时候，不及时取消订阅，就会造成内存泄漏。这里就要用到我们的CompositeDisposable。\n使用 使用的方法大致就是三步：\n ui层创建的时候，实例化我们的CompositeDisposable类。 把订阅返回的disposable对象加入到我们的管理器中。 ui层销毁的时候清空订阅对象。  创建ui的时候实例化 @Override public void onStart() { if (mSubscriptions == null) { mSubscriptions = new CompositeDisposable(); } } 添加disposable对象 netWork.getInstance().getDataService() .translateYouDao(q,from,to,appID,salt,sign,signType,curtime) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Observer\u0026lt;TranslationBean\u0026gt;() { @Override public void onSubscribe(Disposable d) { mSubscriptions.add(d); //这里添加到容器中  } @Override public void onNext(TranslationBean translationBean) { List\u0026lt;TranslationBean\u0026gt; list_word = new ArrayList\u0026lt;\u0026gt;(); list_word.add(translationBean); mView.showResult(list_word); } @Override public void onError(Throwable e) { mView.showConnection(); } @Override public void onComplete() { } }); ui层销毁时候解除订阅 @Override public void onDestroy() { if (mSubscriptions != null) { mSubscriptions.dispose(); mSubscriptions.clear(); mSubscriptions = null; } } 总结 一些细节上的地方自己没能发现，还是得多看看别人代码，遇到不知道用来干嘛的类说不定就是自己忽略掉的地方。\n","date":"2020-03-29T15:13:03Z","permalink":"https://magren.cn/rxjava%E7%9A%84compositedisposable/","title":"Rxjava的CompositeDisposable"},{"content":"RxJava是利用观察者模式来实现一些列的操作，所以对于观察者模式中的观察者，被观察者，以及订阅、事件需要有一个了解。\nObservable：在观察者模式中称为“被观察者”； Observer：观察者模式中的“观察者”，可接收Observable发送的数据； subscribe：订阅，观察者与被观察者，通过Observable的subscribe()方法进行订阅； Subscriber：也是一种观察者，在2.0中 它与Observer没什么实质的区别，不同的是 Subscriber要与Flowable(也是一种被观察者)联合使用，Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable.\n观察者模式 rxjava的实现主要是通过观察者模式实现的。\nA 对象（观察者）对 B 对象（被观察者）的某种变化高度敏感,需要在 B 变化的一瞬间做出反应. 在程序的观察者模式，观察者不需要时刻盯着被观察者,而是采用注册或者称为订阅的方式，告诉被观察者：我需要你的某某状态，你要在它变化的时候通知我 同时我们也可以多个观察者对应一个被观察者\n其实在android中也有很多自带的观察者模式。最明显的莫过于点击事件。说个最简单的例子，点击按钮后弹一个Toast。那么，我们在点击按钮的时候，告知系统，此时，我需要弹一个吐司。那么就这么弹出来了。那么，这个时候问题来了。我是否需要实时去监听这个按钮呢？答案是不需要的。这就和前面的举例有的差距了。换句话说。我只要在此按钮进行点击时进行监听就可以了。这种操作被称为订阅。也就是说Button通过setOnClickListener对OnclickListener进行了订阅了操作，来监听onclick方法。\n基本使用 rxjava的基本实现主要是三点：\n 初始化 Observable （被观察者） 初始化 Observe（观察者） 建立两者之间的订阅关系  创建Observable Observable\u0026lt;String\u0026gt; observable = Observable.create(new ObservableOnSubscribe\u0026lt;String\u0026gt;() { @Override public void subscribe(ObservableEmitter\u0026lt;String\u0026gt; e) throws Exception { e.onNext(\u0026#34;hello world\u0026#34;); e.onComplete(); //调用complete后下面将不再接受事件  } }); 创建Observe Observer\u0026lt;String\u0026gt;observer=new Observer\u0026lt;String\u0026gt;() { @Override public void onSubscribe(Disposable d) { Log.i(\u0026#34;rxjava\u0026#34;, \u0026#34;onSubscribe: \u0026#34; + d); } @Override public void onNext(String string) { Log.i(\u0026#34;rxjava\u0026#34;, \u0026#34;onNext: \u0026#34; + string); } @Override public void onError(Throwable e) { Log.i(\u0026#34;rxjava\u0026#34;, \u0026#34;onError: \u0026#34; + e); } @Override public void onComplete() { Log.i(\u0026#34;rxjava\u0026#34;, \u0026#34;onComplete: \u0026#34;); } };  onSubscribe：它会在事件还未发送之前被调用，可以用来做一些准备操作。而里面的Disposable则是用来切断上下游的关系的。 onNext：普通的事件。将要处理的事件添加到队列中。 onError：事件队列异常，在事件处理过程中出现异常情况时，此方法会被调用。同时队列将会终止，也就是不允许在有事件发出。 onComplete：事件队列完成。rxjava不仅把每个事件单独处理。而且会把他们当成一个队列。当不再有onNext事件发出时，需要触发onComplete方法作为完成标识。  创建订阅 observable.subscribe(observer);\n结果 先调用onSubscribe，然后走了onNext，最后以onComplete收尾：  输出结果 \n线程的调度  subscribeOn() 指定的是发射事件的线程，observerOn 指定的就是订阅者接收事件的线程。 多次指定发射事件的线程只有第一次指定的有效，也就是说多次调用 subscribeOn() 只有第一次的有效，其余的会被忽略。 但多次指定订阅者接收线程是可以的，也就是说每调用一次 observerOn()，下游的线程就会切换一次。  rxjava中已经内置了一些线程供我们选择：\n Schedulers.io() 代表io操作的线程, 通常用于网络,读写文件等io密集型的操作 Schedulers.computation() 代表CPU计算密集型的操作, 例如需要大量计算的操作 Schedulers.newThread() 代表一个常规的新线程 AndroidSchedulers.mainThread() 代表Android的主线程  例子： Observable\u0026lt;String\u0026gt; observable = Observable.create(new ObservableOnSubscribe\u0026lt;String\u0026gt;() { @Override public void subscribe(ObservableEmitter\u0026lt;String\u0026gt; e) throws Exception { e.onNext(\u0026#34;hello world \u0026#34;+ Thread.currentThread().getName()); e.onComplete(); //调用complete后下面将不再接受事件  } }).subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) //切换到主线程  .doOnNext(new Consumer\u0026lt;String\u0026gt;() { @Override public void accept(String s) throws Exception { Log.i(\u0026#34;rxjava\u0026#34;,\u0026#34;主线程 \u0026#34;+Thread.currentThread().getName()); } }) .observeOn(Schedulers.io()) .doOnNext(new Consumer\u0026lt;String\u0026gt;() { @Override public void accept(String s) throws Exception { Log.i(\u0026#34;rxjava\u0026#34;,\u0026#34;thread \u0026#34;+Thread.currentThread().getName()); } }); 结果 2020-03-13 17:06:23.873 8760-8760/com.example.rxjava_test I/rxjava: onSubscribe: io.reactivex.internal.operators.observable.ObservableDoOnEach$DoOnEachObserver@92153c7 2020-03-13 17:06:23.980 8760-8760/com.example.rxjava_test I/rxjava: 主线程 main 2020-03-13 17:06:23.982 8760-8826/com.example.rxjava_test I/rxjava: thread RxCachedThreadScheduler-1 2020-03-13 17:06:23.982 8760-8826/com.example.rxjava_test I/rxjava: onNext: hello world RxNewThreadScheduler-1 2020-03-13 17:06:23.982 8760-8826/com.example.rxjava_test I/rxjava: onComplete: 结合rxjava和retorfit 创建接收服务器返回数据的类 public class TranslationBean { private int errorCode; //错误返回码  private String query; //源语言  private List\u0026lt;String\u0026gt; translation; //翻译结果  private basicEntity basic; private List\u0026lt;WebEntity\u0026gt; web; private String tSpeakUrl; public class basicEntity { @SerializedName(\u0026#34;us-phonetic\u0026#34;) private String usPhonetic; //英式音标  @SerializedName(\u0026#34;uk-speech\u0026#34;) private String ukSpeech; //美式发音  @SerializedName(\u0026#34;us-speech\u0026#34;) private String usSpeech; //英式发音  private String phonetic; //默认音标  @SerializedName(\u0026#34;uk-phonetic\u0026#34;) private String ukPhonetic; //美式英标  private List\u0026lt;String\u0026gt; explains; //基本释义  public List\u0026lt;String\u0026gt; getExplains() { return explains; } public void setExplains(List\u0026lt;String\u0026gt; explains) { this.explains = explains; } public String getPhonetic() { return phonetic; } public void setPhonetic(String phonetic) { this.phonetic = phonetic; } public String getUkPhonetic() { return ukPhonetic; } public void setUkPhonetic(String ukPhonetic) { this.ukPhonetic = ukPhonetic; } public String getUsPhonetic() { return usPhonetic; } public void setUsPhonetic(String usPhonetic) { this.usPhonetic = usPhonetic; } public String getUkSpeech() { return ukSpeech; } public void setUkSpeech(String ukSpeech) { this.ukSpeech = ukSpeech; } public String getUsSpeech() { return usSpeech; } public void setUsSpeech(String usSpeech) { this.usSpeech = usSpeech; } } public class WebEntity { private String key; private List\u0026lt;String\u0026gt; value; public void setKey(String key) { this.key = key; } public void setValue(List\u0026lt;String\u0026gt; value) { this.value = value; } public String getKey() { return key; } public List\u0026lt;String\u0026gt; getValue() { return value; } } public void setQuery(String query) { this.query = query; } public void setErrorCode(int errorCode) { this.errorCode = errorCode; } public void setTranslation(List\u0026lt;String\u0026gt; translation) { this.translation = translation; } public void setWeb(List\u0026lt;WebEntity\u0026gt; web) { this.web = web; } public String getQuery() { return query; } public int getErrorCode() { return errorCode; } public List\u0026lt;String\u0026gt; getTranslation() { return translation; } public List\u0026lt;WebEntity\u0026gt; getWeb() { return web; } public basicEntity getBasic() { return basic; } public void setBasic(basicEntity basic) { this.basic = basic; } public void settSpeakUrl(String tSpeakUrl){ this.tSpeakUrl = tSpeakUrl;} public String gettSpeakUrl(){ return tSpeakUrl; } } 创建用于描述网络请求的接口 public interface networkApi { @GET(\u0026#34;api?\u0026#34;) Observable\u0026lt;TranslationBean\u0026gt; translateYouDao( @Query(\u0026#34;q\u0026#34;) String q, @Query(\u0026#34;from\u0026#34;) String from, @Query(\u0026#34;to\u0026#34;) String to, @Query(\u0026#34;appKey\u0026#34;) String appKey, //应用ID  @Query(\u0026#34;salt\u0026#34;) String salt, //UUID  @Query(\u0026#34;sign\u0026#34;) String sign, //应用ID+input+salt+curtime+应用密钥 。 input= q前10个字符+q长度+q后10个字符（q的长度\u0026gt;=20） 或input = 字符串  @Query(\u0026#34;signType\u0026#34;) String signType, //签名类型  @Query(\u0026#34;curtime\u0026#34;) String curtime //时间戳  ); } 创建Retorfit public class netWork { private static networkApi sContactsApi; private static OkHttpClient okHttpClient = new OkHttpClient(); private static Converter.Factory gsonConverterFactory = GsonConverterFactory.create(); private static CallAdapter.Factory rxJavaCallAdapterFactory = RxJava2CallAdapterFactory.create(); private static class ApiClientHolder { public static final netWork INSTANCE = new netWork(); } public static netWork getInstance() { return ApiClientHolder.INSTANCE; } public networkApi getDataService() { if (sContactsApi == null) { Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .baseUrl(Constants.BASE_URL) .addConverterFactory(gsonConverterFactory) .addCallAdapterFactory(rxJavaCallAdapterFactory) .build(); sContactsApi = retrofit.create(networkApi.class); } return sContactsApi; } } 使用 @SuppressLint(\u0026#34;CheckResult\u0026#34;) public void netConnection(String q,String from,String to,String salt,String sign,String curtime){ netWork.getInstance().getDataService() .translateYouDao(q,from,to,appID,salt,sign,signType,curtime) .subscribeOn(Schedulers.newThread()) //发起的执行在一个新的线程  .observeOn(AndroidSchedulers.mainThread()) //结果的执行在主线程  .subscribe(new Consumer\u0026lt;TranslationBean\u0026gt;() { @Override public void accept(TranslationBean translationBean) throws Exception { //对接收到数据的类进行处理  } }); } ","date":"2020-03-13T14:59:35Z","permalink":"https://magren.cn/android%E7%9A%84rxjava2/","title":"Android的rxjava2"},{"content":"先上Google提供的经典图，是对Activity生命周期各个阶段之间导航转换的直观展现。\nActivity类提供了六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop()和onDestroy()。\n 生命周期 \n说明  在正常的情况下，Activity从启动到结束会按以下的顺序经历整个生命周期：onCreate()-\u0026gt;onStart()-\u0026gt;onResume()-\u0026gt;onPause()-\u0026gt;onStop()-\u0026gt;onDestory()。 onCreate():系统首次创建Activity的时候触发，可以做一些初始化的工作，比如初始化Activity所需要的数据，还有调用setContentView加载界面布局资源。 onRestart()：表示Activity正在重新启动。一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。这种情形一般是用户行为导致的，比如用户按Home键切换到桌面或打开了另一个新的Activity，接着用户又回到了这个Actvity。 onStart(): 表示Activity正在被启动，即将开始，这时Activity已经出现了，**但是还没有出现在前台，无法与用户交互。**这个时候可以理解为Activity已经显示出来，但是我们还看不到。 onResume():表示Activity已经可见了，并且出现在前台并开始活动。需要和onStart()对比，onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。 onPause():表示 Activity正在停止，仍可见，正常情况下，紧接着onStop就会被调，onPause中不能进行耗时操作，会影响到新Activity的显示。因为onPause必须执行完，新的Activity的onResume才会执行。 onStop():表示Activity即将停止，不可见，位于后台。可以做稍微重量级的回收工作，同样不能太耗时。 onDestory():表示Activity即将销毁，这是Activity生命周期的最后一个回调，可以做一些回收工作和最终的资源回收。  几种普遍情况 从A页面Activity跳转到B页面Activity，然后关闭B页面Activity，回到A页面Activity  针对开启的B页面Activity，第一次启动，回调如下：onCreate()-\u0026gt;onStart()-\u0026gt;onResume() 用户打开B页面Activiy的时候，A页面的Activity处于不可见的回调如下：onPause()-\u0026gt;onStop() 再次从B页面回到A页面原Activity时，A页面从不可见到可见回调如下：onRestart()-\u0026gt;onStart()-\u0026gt;onResume() 按back键回退时，B页面Activity回调如下：onPause()-\u0026gt;onStop()-\u0026gt;onDestory() 按Home键切换到桌面后又回到A页面该Actitivy，回调如下：onPause()-\u0026gt;onStop()-\u0026gt;onRestart()-\u0026gt;onStart()-\u0026gt;onResume() 调用finish()方法后，回调如下：onDestory()(以在onCreate()方法中调用为例，不同方法中回调不同，通常都是在onCreate()方法中调用)  Activity的三种运行状态 Resumed（活动状态）  又叫Running状态，这个Activity正在屏幕上显示，并且有用户焦点。这个很好理解，就是用户正在操作的那个界面。\n Paused（暂停状态）  这是一个比较不常见的状态。这个Activity在屏幕上是可见的，但是并不是在屏幕最前端的那个Activity。比如有另一个非全屏或者透明的Activity是Resumed状态，没有完全遮盖这个Activity。\n Stopped（停止状态）  当Activity完全不可见时，此时Activity还在后台运行，仍然在内存中保留Activity的状态，并不是完全销毁。这个也很好理解，当跳转的另外一个界面，之前的界面还在后台，按回退按钮还会恢复原来的状态，大部分软件在打开的时候，直接按Home键，并不会关闭它，此时的Activity就是Stopped状态。\n 部分流程分支  启动Activity: onCreate()—\u0026gt;onStart()—\u0026gt;onResume()，Activity进入运行状态。 Activity退居后台: 当前Activity转到新的Activity界面或按Home键回到主屏： onPause()—\u0026gt;onStop()，进入停滞状态。 Activity返回前台: onRestart()—\u0026gt;onStart()—\u0026gt;onResume()，再次回到运行状态。 Activity退居后台，且系统内存不足， 系统会杀死这个后台状态的Activity（此时这个Activity引用仍然处在任务栈中，只是这个时候引用指向的对象已经为null），若再次回到这个Activity,则会走onCreate()–\u0026gt;onStart()—\u0026gt;onResume()(将重新走一次Activity的初始化生命周期) 锁屏：onPause()-\u0026gt;onStop() 解锁：onStart()-\u0026gt;onResume()  横竖屏下切换 第一种情况，销毁当前的Activity： 在横竖屏切换的过程中，Activity会先销毁后重建，也应该避免这种情况。 这里有两个回调：\n onSaveInstanceState和onRestoreInstanceState。 在Activity由于异常情况下终止时，系统会调用onSaveInstanceState来保存当前Activity的状态。这个方法的调用是在onStop之前，它和onPause没有既定的时序关系，该方法只在Activity被异常终止的情况下调用。当异常终止的Activity被重建以后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象参数同时传递给onRestoreInstanceState和onCreate方法。因此，可以通过onRestoreInstanceState方法来恢复Activity的状态，该方法的调用时机是在onStart之后。其中onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别： onRestoreInstanceState回调则表明其中Bundle对象非空，不用加非空判断。onCreate需要非空判断。建议使用onRestoreInstanceState。 简单来说，这个过程Activity的生命周期为：onPause()-\u0026gt;onSaveInstanceState()-\u0026gt; onStop()-\u0026gt;onDestroy()-\u0026gt;onCreate()-\u0026gt;onStart()-\u0026gt;onRestoreInstanceState-\u0026gt;onResume()  第二种情况，当前的Activity 不销毁，但是我们需要设置Activity的属性： 可以通过在AndroidManifest文件的Activity中指定如下属性：\n\u0026lt;activity android:name=\u0026#34;.activity.VideoDetailActivity\u0026#34; android:configChanges=\u0026#34;orientation|keyboardHidden|screenSize\u0026#34; android:screenOrientation=\u0026#34;portrait\u0026#34;/\u0026gt; 通过回调下面的方法，避免横竖屏切换的时候Activity的销毁和重建：\n@Override public void onConfigurationChanged(Configuration newConfig) { super.onConfigurationChanged(newConfig); } 当资源不足的时候，保留Activity的优先级顺序：  前台Activity——正在和用户交互的Activity，优先级最高。 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户交互。 后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。  ","date":"2020-03-06T14:36:01Z","permalink":"https://magren.cn/android-activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","title":"Android Activity生命周期"},{"content":"虽然在大学以来学习了一年多的安卓，已经可以完成一部分的需求，但是在Android这方面的底层知识和一些概念我应该不算非常了解，借着这个长假的机会打算好好熟悉下。\nAndroid内存泄漏 内存泄漏是指保存了不可能再被访问的变量引用，导致垃圾回收器无法回收内存。 也就是说： 在Java中有些对象的生命周期是有限的，当它们完成了特定的逻辑后会被回收，但是，如果在对象的生命周期本该被回收时，这个对象仍然还被别的对象所持有引用，那么就会导致内存泄漏。 具体例子：\npublic class LeakAct extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.aty_leak); test(); } public void test() { new Thread(new Runnable() { @Override public void run() { while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }z } }).start(); } } test是一个非静态内部类，当我们finish的时候，该实例不会真正销毁，GC机制也不会进行该实例的垃圾回收，因为***匿名内部类和非静态内部类持有外部类的强引用， ***也就是说test持有外部activity的强引用，而thread内部while(true)是死循环，线程不会停止，对外部activity的强引用也不会消失。这样就造成了内存泄漏。\n解决方案\n 1.将内部类变成静态内部类; 2.如果有强引用Activity中的属性，则将该属性的引用方式改为弱引用; 3.在业务允许的情况下，当Activity执行onDestory时，结束这些耗时任务;\n Android内存溢出 内存溢出指的是APP向系统申请超过最大阀值的内存请求，系统不会再分配多余的空间，从而造成内存溢出\n 典型的例子就是加载多张大图，导致内存耗尽，可以对图片进行适当的质量压缩或者尺寸压缩。 当某个界面存在内存泄露，反复进入该界面，将导致一直有新对象创建但是无法回收，最终导致内存耗尽，造成内存溢出。  ","date":"2020-03-01T14:27:13Z","permalink":"https://magren.cn/%E8%AF%B4%E8%AF%B4android%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E6%BA%A2%E5%87%BA/","title":"说说Android的内存泄露和溢出"},{"content":"这个项目其实去年就有写了，但是那时候没有用到基类，然后用的是网易云有道翻译的sdk，耦合方面也不是做的很好，在寒假这段时间便把它重构了一遍， 同时用上了rxjava2和retorfit来进行网络的请求以及用上了ButterKnife。这个项目就当作自己的一个学习吧，后面还有什么可以优化的地方再逐步更新。\n 附上项目地址：starTranslation\n 部分知识点 Retorfit和RxJava2搭配的使用 1.创建Service类 因为要结合使用RxJava，所以返回值就不在是一个Call了，而是一个Observable。\npublic interface networkApi { @GET(\u0026#34;api?\u0026#34;) Observable\u0026lt;TranslationBean\u0026gt; translateYouDao( @Query(\u0026#34;q\u0026#34;) String q, @Query(\u0026#34;from\u0026#34;) String from, @Query(\u0026#34;to\u0026#34;) String to, @Query(\u0026#34;appKey\u0026#34;) String appKey, //应用ID  @Query(\u0026#34;salt\u0026#34;) String salt, //UUID  @Query(\u0026#34;sign\u0026#34;) String sign, //应用ID+input+salt+curtime+应用密钥 。 input= q前10个字符+q长度+q后10个字符（q的长度\u0026gt;=20） 或input = 字符串  @Query(\u0026#34;signType\u0026#34;) String signType, //签名类型  @Query(\u0026#34;curtime\u0026#34;) String curtime //时间戳  ); } 2.创建请求的过程v public class netWork { private static networkApi sContactsApi; private static OkHttpClient okHttpClient = new OkHttpClient(); private static Converter.Factory gsonConverterFactory = GsonConverterFactory.create(); private static CallAdapter.Factory rxJavaCallAdapterFactory = RxJava2CallAdapterFactory.create(); private static class ApiClientHolder { public static final netWork INSTANCE = new netWork(); } public static netWork getInstance() { return ApiClientHolder.INSTANCE; } public networkApi getDataService() { if (sContactsApi == null) { Retrofit retrofit = new Retrofit.Builder() .client(okHttpClient) .baseUrl(Constants.BASE_URL) .addConverterFactory(gsonConverterFactory) .addCallAdapterFactory(rxJavaCallAdapterFactory) .build(); sContactsApi = retrofit.create(networkApi.class); } return sContactsApi; } } 3.发出请求以及处理数据 @SuppressLint(\u0026#34;CheckResult\u0026#34;) public void netConnection(String q,String from,String to,String salt,String sign,String curtime){ netWork.getInstance().getDataService() .translateYouDao(q,from,to,appID,salt,sign,signType,curtime) .subscribeOn(Schedulers.newThread()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Consumer\u0026lt;TranslationBean\u0026gt;() { @Override public void accept(TranslationBean translationBean) throws Exception { List\u0026lt;TranslationBean\u0026gt; list_word = new ArrayList\u0026lt;\u0026gt;(); list_word.add(translationBean); mView.showResult(list_word); } }); } 4.拓展 上面的写法是通过之前师兄的源码学习到的，在封装方面做的不是很好，在搜索别人的使用方法的时候找到了别人的封装方法，有时间的话需要再好好梳理下\n 这里是别人的写法：Android 优雅的让RxJava2.0+Retrofit2.0结合使用\n 关于Toolbar Toolbar是一个很强大的控件，同时基本上每一个Activtiy都是需要它，在以前我是每个Layout都写上一个toolbar的，然后用ButterKnife初始化view，但是这样写非常麻烦……于是我将toolbar封装到了BaseActivity里，布局方面的话是先按自己的需求写一个toolbar的布局，然后在需要的地方include（viewpager的切换界面按钮我也是这样写的）。\n具体的使用 首先写一个toolbar的布局\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;androidx.appcompat.widget.Toolbar xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;#1B6FB3\u0026#34; android:layout_alignParentTop=\u0026#34;true\u0026#34; android:id=\u0026#34;@+id/mtoolbar\u0026#34; android:layout_height=\u0026#34;?attr/actionBarSize\u0026#34; android:theme=\u0026#34;@style/ThemeOverlay.AppCompat.Dark.ActionBar\u0026#34;\u0026gt; \u0026lt;/androidx.appcompat.widget.Toolbar\u0026gt; 接着在需要的地方include进去就好了\n\u0026lt;include layout=\u0026#34;@layout/view_toolbar\u0026#34;/\u0026gt; 同样的方法还可以用来写tab栏等\nroom的使用 由于之前用room的时候都没有升级过数据库，所以这个坑还真是第一次踩到，在我修改了表以后根据我拙劣的英语我看懂了它需要我升级version，但在我升级version后\n java.lang.IllegalStateException: A migration from 1 to 2 is necessary. Please provide a Migration in the builder or call fallbackToDestructiveMigration in the builder in which case Room will re-create all of the tables.\n 这是什么玩意啊？？？复制粘贴去google了一下，有两种办法\n增加vesion，使用fallback migration 数据被清除 private static wordDatabase buildDatabase(Context context) { return Room.databaseBuilder(context.getApplicationContext(), wordDatabase.class, \u0026#34;StarWord.db\u0026#34;) .allowMainThreadQueries() .fallbackToDestructiveMigration() //升级仓库的时候会重建，数据会清空  .build(); } 这时候room启动时会检测版本是否有增加，如果有，那么数据库的内容会给清空，重新建表。\nvesion增加，提供Migration 数据正常 我没有使用这种方法，因为我后面应该不会再修改数据库，不过还是要学习下\n//添加一个version：1-\u0026gt;2的migration static final Migration MIGRATION_1_2 = new Migration(1, 2) { @Override public void migrate(SupportSQLiteDatabase database) { // 这里写表的修改  //database.execSQL(\u0026#34;ALTER TABLE Starword \u0026#34; + \u0026#34; ADD COLUMN test INTEGER\u0026#34;); 给表添加一列字段，列名为test  } }; 接着把这个migration添加到databaseBuilder中\nprivate static wordDatabase buildDatabase(Context context) { return Room.databaseBuilder(context.getApplicationContext(), wordDatabase.class, \u0026#34;StarWord.db\u0026#34;) .allowMainThreadQueries() .addMigrations(MIGRATION_1_2) .build(); } 这时候数据库的表就更新了，同时旧数据也保存了下来。\n自我反思  在一开始，点击收藏列表的单词的时候我是准备让viewpager跳转回第一页，然后重新进行一次搜索，但是在适配器中返回的view是每个item的view，暂时没想到怎么跳转，于是才有了弹出一个Dialog的替代方法。依然还没找到解决的办法…… 虽然有Retorfit的数据实体类，但是我还是写了一个Room的数据类来存储数据，可以的话想写成一个类，减少代码量。 一些细节没有做好，在整体上APP的生动性依然不足  先这样吧，后面还遇到什么坑的话再继续补充。\n","date":"2020-02-03T16:16:20Z","permalink":"https://magren.cn/%E5%85%B3%E4%BA%8Estartranslation/","title":"关于starTranslation"},{"content":" 这两天开始放寒假，在家呆着也是呆着，遂决定找星空以前Android方向大佬写的项目学习下，看看别人代码的结构以及有什么方法可以降低代码的耦合度，然后在师兄的项目里接触到了BaseActivity，在这里记录一下\n 为什么设计基类  方便代码编写，减少重复代码和冗余逻辑，优化代码 优化程序架构，降低耦合度，方便拓展、修改 版面更干净，减少了诸如生命周期日志等重复逻辑的占用版面  设计的基本思路  生命周期的调试日志输出 绑定视图 常用OnClick方法 Back方法，Toast以及Activity等操作 常用第三方工具（ButterKnife等） 标题栏是否显示，是否全屏，初始化数据等  具体基类的封装 BaseActivity public abstract class BaseActivity\u0026lt;P extends BasePresenter\u0026gt; extends AppCompatActivity implements BaseView\u0026lt;P\u0026gt; { @BindView(R.id.toolbar) Toolbar mToolbar; Unbinder bind; /** * 进度对话框 */ protected ProgressDialog mProgressDialog; /** * 泛型确定Presenter */ protected P mPresenter; @Override protected final void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 设置为竖屏  setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT); setContentView(bindLayout()); // ButterKnife绑定布局  bind = ButterKnife.bind(this); mPresenter = createPresenter(); if (mPresenter != null) { // 调用Presenter初始化方法  mPresenter.onStart(); } // 准备数据  prepareData(); // 初始化标题栏  initToolbar(); // 初始化视图  initView(); // 初始化数据  initData(savedInstanceState); // 初始化事件监听  initEvent(); } /** * 创建Presenter * * @return 泛型Presenter */ protected abstract P createPresenter(); /** * 实现BasePresenter接口的setPresenter方法 * * @param presenter createPresenter()创建的Presenter */ @Override public void setPresenter(P presenter) { mPresenter = presenter; } /** * 初始化Toolbar */ private void initToolbar() { setSupportActionBar(mToolbar); } /** * 设置Toolbar标题 * * @param title 标题 */ protected void setToolbarTitle(String title) { if (getSupportActionBar() != null) { getSupportActionBar().setTitle(title); } } /** * 设置Toolbar显示返回按钮及标题 * * @param title 标题 */ protected void setToolbarBackEnable(String title) { if (getSupportActionBar() != null) { getSupportActionBar().setDisplayHomeAsUpEnabled(true); getSupportActionBar().setHomeAsUpIndicator(R.drawable.ic_arrow_white_24dp); setToolbarTitle(title); } } /** * 绑定布局 * * @return 布局文件的资源ID */ protected abstract int bindLayout(); /** * 准备数据（从Intent获取上一个界面传过来的数据或其他需要初始化的数据） */ protected abstract void prepareData(); /** * 初始化视图，findViewById等等 */ protected abstract void initView(); /** * 初始化数据，从本地或服务器开始获取数据 * * @param savedInstanceState 界面非正常销毁时保存的数据 */ protected abstract void initData(Bundle savedInstanceState); /** * 初始化事件监听，setOnClickListener等等 */ protected abstract void initEvent(); /** * 实现BaseView的showToast(CharSequence msg) * * @param msg 吐司显示的信息 */ @Override public void showToast(CharSequence msg) { ToastUtils.shortToast(this, msg); } /** * 实现BaseView的showToast(int msgId) * * @param msgId 吐司显示的字符串资源id */ @Override public void showToast(int msgId) { ToastUtils.shortToast(this, msgId); } /** * 实现BaseView的showLoadingDialog(CharSequence msg) * 显示加载对话框 * * @param msg 对话框的提示内容 */ @Override public void showLoadingDialog(CharSequence msg) { if (mProgressDialog == null) { mProgressDialog = new ProgressDialog(this); mProgressDialog.setTitle(R.string.title_dialog_tips); mProgressDialog.setMessage(msg); } else { mProgressDialog.setTitle(R.string.title_dialog_tips); } mProgressDialog.show(); } /** * 实现BaseView的hideLoadingDialog() * 隐藏加载对话框 */ @Override public void hideLoadingDialog() { if (mProgressDialog != null \u0026amp;\u0026amp; mProgressDialog.isShowing()) { mProgressDialog.dismiss(); } } /** * Activity销毁时清理资源 */ @Override protected void onDestroy() { // ButterKnife解除绑定  bind.unbind(); // 销毁Presenter  if (mPresenter != null) { mPresenter.onDestroy(); } super.onDestroy(); } /** * 隐藏键盘 */ public void hideKeyboard() { View view = getCurrentFocus(); if (view != null) { ((InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE)). hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS); } } @Override protected void onPause() { super.onPause(); // （仅有Activity的应用中SDK自动调用，不需要单独写）  // 保证 onPageEnd 在onPause之前调用,因为 onPause 中会保存信息。  MobclickAgent.onPageEnd(this.getClass().getSimpleName()); MobclickAgent.onPause(this); } @Override protected void onResume() { super.onResume(); //统计页面(仅有Activity的应用中SDK自动调用，不需要单独写。)  MobclickAgent.onPageStart(this.getClass().getSimpleName()); //统计时长  MobclickAgent.onResume(this); } @Override public boolean onOptionsItemSelected(MenuItem item) { if (item.getItemId() == android.R.id.home) { finish(); } return super.onOptionsItemSelected(item); } } BaseFragment public abstract class BaseFragment\u0026lt;P extends BasePresenter\u0026gt; extends Fragment implements BaseView\u0026lt;P\u0026gt; { @BindView(R.id.toolbar) Toolbar mToolbar; private Unbinder mUnbinder; protected P mPresenter; protected ProgressDialog mProgressDialog; private ActionBar mActionbar; @Nullable @Override public final View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { mPresenter = createPresenter(); if (mPresenter != null) { mPresenter.onStart(); } View root = inflater.inflate(bindLayout(), container, false); mUnbinder = ButterKnife.bind(this, root); prepareData(savedInstanceState); initToolbar(); // 初始化视图  initView(root); initData(savedInstanceState); initEvent(); return root; } protected abstract P createPresenter(); @Override public void setPresenter(P presenter) { mPresenter = presenter; } /** * 准备数据 * * @param savedInstanceState */ protected abstract void prepareData(Bundle savedInstanceState); /** * 绑定fragment的布局文件 * * @return */ protected abstract int bindLayout(); /** * 初始化数据 * * @param savedInstanceState */ protected abstract void initData(Bundle savedInstanceState); /** * 初始化界面 * * @param rootView */ protected abstract void initView(View rootView); /** * 初始化事件监听器 */ protected abstract void initEvent(); /** * 初始化Toolbar */ private void initToolbar() { ((AppCompatActivity) getActivity()).setSupportActionBar(mToolbar); mActionbar = ((AppCompatActivity) getActivity()).getSupportActionBar(); } /** * 设置Toolbar标题 * * @param title 标题 */ protected void setToolbarTitle(String title) { if (mActionbar != null) { mActionbar.setTitle(title); } } /** * 设置Toolbar显示返回按钮及标题 * * @param title 标题 */ protected void setToolbarBackEnable(String title) { if (mActionbar != null) { mActionbar.setDisplayHomeAsUpEnabled(true); mActionbar.setHomeAsUpIndicator(R.drawable.ic_arrow_white_24dp); } } @Override public void showToast(CharSequence msg) { ToastUtils.shortToast(APP.getAppContext(), msg); } @Override public void showToast(int msgId) { ToastUtils.shortToast(APP.getAppContext(), msgId); } @Override public void onDestroy() { super.onDestroy(); } @Override public void showLoadingDialog(CharSequence msg) { if (mProgressDialog == null) { mProgressDialog = new ProgressDialog(getContext()); mProgressDialog.setMessage(msg); } else { mProgressDialog.setTitle(R.string.title_dialog_tips); } mProgressDialog.show(); } @Override public void hideLoadingDialog() { if (mProgressDialog != null \u0026amp;\u0026amp; mProgressDialog.isShowing()) { mProgressDialog.dismiss(); } } @Override public void onDetach() { mUnbinder.unbind(); super.onDetach(); } @Override public void onDestroyView() { if (mPresenter != null) { mPresenter.onDestroy(); } super.onDestroyView(); } @Override public void onResume() { super.onResume(); MobclickAgent.onPageStart(this.getClass().getSimpleName()); } @Override public void onPause() { super.onPause(); MobclickAgent.onPageEnd(this.getClass().getSimpleName()); } } BasePresenter public interface BasePresenter { void onStart(); void onDestroy(); } BaseView public interface BaseView\u0026lt;P\u0026gt; { void setPresenter(P presenter); void showToast(CharSequence msg); void showToast(int msgId); void showLoadingDialog(CharSequence msg); void hideLoadingDialog(); } Impl类 public abstract class BasePresenterImpl implements BasePresenter { protected CompositeDisposable mSubscriptions; @Override public void onStart() { if (mSubscriptions == null) { mSubscriptions = new CompositeDisposable(); } } @Override public void onDestroy() { if (mSubscriptions != null) { mSubscriptions.dispose(); mSubscriptions.clear(); } } } APP类  用于获取全局的context\n public class APP extends Application { private static Context appContext; private static long exitTime = 0; /** * 获取Application的Context * * @return 全局Context */ public static Context getAppContext() { return appContext; } @Override public void onCreate() { super.onCreate(); appContext = getApplicationContext(); } /** * 退出APP */ public static void exitApp() { if (System.currentTimeMillis() - exitTime \u0026gt; 2000) { ToastUtils.shortToast(getAppContext(), appContext.getString(R.string.text_press_again)); exitTime = System.currentTimeMillis(); } else { android.os.Process.killProcess(android.os.Process.myPid()); } } } 具体使用 Contract 契约类  契约类用于定义同一个界面的view和presenter的接口，通过规范的方法命名或注释，可以清晰的看到整个页面的逻辑。\n public interface myContract { interface View extends BaseView\u0026lt;Presenter\u0026gt; { } interface Presenter extends BasePresenter { } } Presenter public class SamplePresenter extends BasePresenterImpl implements myContract.Presenter { private final myContract.View mView; public SamplePresenter(myContract.View view) { mView = view; this.mView.setPresenter(this); } } Activiy public class SampleActivity extends BaseActivity\u0026lt;myContract.Presenter\u0026gt; implements myContract.View { @BindView(R.id.tv_sample_text) TextView mTvSample; @Override protected myContract.Presenter createPresenter() { return new SamplePresenter(this); } @Override protected int bindLayout() { //TODO:添加视图，记得添加androidmanifest  return R.layout.activity_sample; } @Override protected void prepareData() { //TODO:准备数据 比如：从数据库加载数据，或者网络请求数据等等  } @Override protected void initView() { //TODO:初始化视图 比如：recycleview的准备，添加adapter等等  mTvSample.setText(\u0026#34;这是一个sample\u0026#34;); } @Override protected void initData(Bundle savedInstanceState) { //TODO:初始化数据 比如：将数据加入到view中  } @Override protected void initEvent() { //TODO:初始化事件监听 比如：增加监听器，下拉刷新，加载更多等等  } } ","date":"2020-01-09T16:16:20Z","permalink":"https://magren.cn/android%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/","title":"Android基类的设计"}]